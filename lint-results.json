[
  {
    "filePath": "C:\\Users\\micha\\Documents\\dev\\august\\FLASCARD-APP\\src\\App.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'ERROR_MESSAGES' is defined but never used.",
        "line": 21,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 21,
        "endColumn": 42
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'debugFirestore' is defined but never used.",
        "line": 22,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 22,
        "endColumn": 24
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'checkFirestoreRules' is defined but never used.",
        "line": 22,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 22,
        "endColumn": 45
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'initialDueCardsCount' is assigned a value but never used.",
        "line": 229,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 229,
        "endColumn": 30
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'initialSubCategoryStats' is assigned a value but never used.",
        "line": 233,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 233,
        "endColumn": 33
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'allCategories', 'cardsCompletedToday', 'cardsDueToday.length', 'categories', 'categoryCompletedCounts', 'categoryStats', 'debugCurrentFilterState', 'debugSubCategoryTracking', 'filteredDisplayCategories', 'getCategories', 'getSubCategories', 'getSubCategoryStats', 'initialCategoryStats', 'manualTriggerAutoAdvance', 'setSelectedSubCategory', 'setShowDueTodayOnly', 'showStarredOnly', 'subCategories', and 'updateFlashcard'. Either include them or remove the dependency array.",
        "line": 643,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 643,
        "endColumn": 118,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [flashcards, userId, filteredFlashcards, selectedCategory, selectedSubCategory, selectedLevel, showDueTodayOnly, manualTriggerAutoAdvance, debugCurrentFilterState, debugSubCategoryTracking, getSubCategories, getSubCategoryStats, categoryStats, updateFlashcard, categories, allCategories, cardsCompletedToday, cardsDueToday.length, showStarredOnly, filteredDisplayCategories, initialCategoryStats, categoryCompletedCounts, setShowDueTodayOnly, getCategories, subCategories, setSelectedSubCategory]",
            "fix": {
              "range": [
                26776,
                26888
              ],
              "text": "[flashcards, userId, filteredFlashcards, selectedCategory, selectedSubCategory, selectedLevel, showDueTodayOnly, manualTriggerAutoAdvance, debugCurrentFilterState, debugSubCategoryTracking, getSubCategories, getSubCategoryStats, categoryStats, updateFlashcard, categories, allCategories, cardsCompletedToday, cardsDueToday.length, showStarredOnly, filteredDisplayCategories, initialCategoryStats, categoryCompletedCounts, setShowDueTodayOnly, getCategories, subCategories, setSelectedSubCategory]"
            }
          }
        ]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'createDefaultFlashcards'. Either include it or remove the dependency array.",
        "line": 699,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 699,
        "endColumn": 83,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [isAuthReady, userId, addFlashcard, flashcards.length, hasCheckedForDefaults, createDefaultFlashcards]",
            "fix": {
              "range": [
                29071,
                29148
              ],
              "text": "[isAuthReady, userId, addFlashcard, flashcards.length, hasCheckedForDefaults, createDefaultFlashcards]"
            }
          }
        ]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "The 'handleReviewCard' function makes the dependencies of useEffect Hook (at line 1881) change on every render. To fix this, wrap the definition of 'handleReviewCard' in its own useCallback() Hook.",
        "line": 769,
        "column": 9,
        "nodeType": "VariableDeclarator",
        "endLine": 1011,
        "endColumn": 4,
        "suggestions": [
          {
            "desc": "Wrap the definition of 'handleReviewCard' in its own useCallback() Hook.",
            "fix": {
              "range": [
                31174,
                41109
              ],
              "text": "useCallback(async (rating) => {\r\n    const card = getCurrentCard();\r\n    if (!card) {\r\n      console.error('No current card found for review');\r\n      return;\r\n    }\r\n\r\n    // console.log('üîÑ Reviewing card:', card.id, 'Rating:', rating);\r\n\r\n    try {\r\n      // FSRS algorithm implementation\r\n      const now = new Date();\r\n      let { \r\n        easeFactor = 2.5, \r\n        interval = 1, \r\n        repetitions = 0, \r\n        difficulty = 5, \r\n        stability = 2,\r\n        lastReviewed \r\n      } = card;\r\n      \r\n      // Convert rating to numeric value\r\n      const ratingMap = { again: 1, hard: 2, good: 3, easy: 4 };\r\n      const numRating = ratingMap[rating];\r\n      \r\n      // FSRS parameters from settings\r\n      const { \r\n        requestRetention = 0.9, \r\n        maximumInterval = 36500,\r\n        w = DEFAULT_FSRS_PARAMS.w,\r\n        againFactor = 0.5,\r\n        hardFactor = 0.8,\r\n        goodFactor = 1.0,\r\n        easyFactor = 1.3,\r\n        initialAgainInterval = 1,\r\n        initialHardInterval = 1,\r\n        initialGoodInterval = 4,\r\n        initialEasyInterval = 15\r\n      } = fsrsParams;\r\n      \r\n      // Calculate elapsed days since last review\r\n      const lastReviewDate = lastReviewed ? (lastReviewed.toDate ? lastReviewed.toDate() : new Date(lastReviewed)) : null;\r\n      const elapsedDays = lastReviewDate ? Math.max(1, Math.round((now - lastReviewDate) / (1000 * 60 * 60 * 24))) : 0;\r\n      \r\n      // FSRS-4.5 algorithm implementation\r\n      if (numRating === 1) { // Again\r\n        repetitions = 0;\r\n        \r\n        // For first review or after a lapse\r\n        if (card.repetitions === 0) {\r\n          interval = initialAgainInterval / (24 * 60); // Convert minutes to days\r\n        } else {\r\n          // Use againFactor to reduce the interval\r\n          interval = Math.max(1, Math.round(interval * againFactor));\r\n        }\r\n        \r\n        // Increase difficulty\r\n        difficulty = Math.min(10, difficulty + w[6]);\r\n        \r\n        // Reduce stability significantly\r\n        stability = stability * Math.exp(w[11] * Math.pow(difficulty, w[12]));\r\n        stability = Math.max(0.1, stability);\r\n        \r\n        // Reduce ease factor\r\n        easeFactor = Math.max(1.3, easeFactor - 0.2);\r\n        \r\n      } else if (numRating === 2) { // Hard\r\n        \r\n        if (repetitions === 0) {\r\n          interval = initialHardInterval / (24 * 60); // Convert minutes to days\r\n        } else {\r\n          // Apply hard factor to current interval\r\n          const newInterval = interval * hardFactor;\r\n          // But also consider the actual elapsed time\r\n          interval = Math.max(elapsedDays + 1, Math.round(newInterval));\r\n        }\r\n        \r\n        repetitions++;\r\n        \r\n        // Slightly increase difficulty\r\n        difficulty = Math.min(10, difficulty + w[5] * 0.5);\r\n        \r\n        // Slightly reduce stability\r\n        const recallProbability = Math.exp(-elapsedDays / stability);\r\n        stability = stability * (1 + Math.exp(w[8]) * (11 - difficulty) * Math.pow(stability, w[9]) * (Math.exp(recallProbability * w[10]) - 1));\r\n        \r\n        // Slightly reduce ease factor\r\n        easeFactor = Math.max(1.3, easeFactor - 0.15);\r\n        \r\n      } else if (numRating === 3) { // Good\r\n        \r\n        if (repetitions === 0) {\r\n          interval = initialGoodInterval;\r\n        } else if (repetitions === 1) {\r\n          interval = initialGoodInterval * 1.5;\r\n        } else {\r\n          // Standard interval calculation with goodFactor\r\n          const newInterval = interval * easeFactor * goodFactor;\r\n          interval = Math.round(newInterval);\r\n        }\r\n        \r\n        repetitions++;\r\n        \r\n        // Maintain or slightly reduce difficulty\r\n        difficulty = Math.max(1, difficulty - w[6] * 0.3);\r\n        \r\n        // Increase stability based on successful recall\r\n        const recallProbability = Math.exp(-elapsedDays / stability);\r\n        stability = stability * (1 + Math.exp(w[8]) * (11 - difficulty) * Math.pow(stability, w[9]) * (Math.exp(recallProbability * w[10]) - 1));\r\n        \r\n        // Maintain ease factor\r\n        // easeFactor stays the same\r\n        \r\n      } else if (numRating === 4) { // Easy\r\n        \r\n        if (repetitions === 0) {\r\n          interval = initialEasyInterval;\r\n        } else {\r\n          // Apply easy bonus to interval\r\n          const newInterval = interval * easeFactor * easyFactor;\r\n          interval = Math.round(newInterval);\r\n        }\r\n        \r\n        repetitions++;\r\n        \r\n        // Reduce difficulty\r\n        difficulty = Math.max(1, difficulty - w[7]);\r\n        \r\n        // Increase stability more for easy recall\r\n        const recallProbability = Math.exp(-elapsedDays / stability);\r\n        stability = stability * (1 + Math.exp(w[8]) * (11 - difficulty) * Math.pow(stability, w[9]) * (Math.exp(recallProbability * w[10]) - 1) * 1.3);\r\n        \r\n        // Increase ease factor\r\n        easeFactor = Math.min(2.5, easeFactor + 0.15);\r\n      }\r\n      \r\n      // Apply fuzz factor to prevent cards bunching up\r\n      const fuzzRange = interval * (fsrsParams.fuzzFactor || 0.05);\r\n      const fuzz = (Math.random() - 0.5) * 2 * fuzzRange;\r\n      interval = Math.max(1, Math.round(interval + fuzz));\r\n      \r\n      // Apply maximum interval limit\r\n      interval = Math.min(interval, maximumInterval);\r\n      \r\n      // Calculate next due date\r\n      const dueDate = new Date(now.getTime() + interval * 24 * 60 * 60 * 1000);\r\n      \r\n      // Import Timestamp for proper Firestore format\r\n      const { Timestamp } = await import('firebase/firestore');\r\n      \r\n      const updateData = {\r\n        easeFactor,\r\n        interval,\r\n        repetitions,\r\n        difficulty,\r\n        stability,\r\n        dueDate: Timestamp.fromDate(dueDate),\r\n        lastReviewed: Timestamp.fromDate(now),\r\n        reviewCount: (card.reviewCount || 0) + 1,\r\n        level: rating // Store the rating as the level\r\n      };\r\n      \r\n      // console.log('üìù Updating card with data:', updateData);\r\n      // console.log(`üìÖ Next review: ${interval} days from now (${dueDate.toLocaleDateString()})`);\r\n      \r\n      // Add current card to navigation history before updating it\r\n      // This ensures we can navigate back to this card even if it gets filtered out\r\n      addToNavigationHistory(card);\r\n      \r\n      // Update the card\r\n      await updateFlashcard(card.id, updateData);\r\n\r\n      // console.log('‚úÖ Card review successful!');\r\n      // console.log('üìÖ Card new due date:', dueDate);\r\n      // console.log('üìÖ Is card still due today?', dueDate <= new Date());\r\n      // console.log('üîç Current card ID:', card.id);\r\n      // console.log('üîç Update data applied:', updateData);\r\n\r\n      setMessage(`Card reviewed as ${rating.toUpperCase()}! Next review in ${interval} day${interval !== 1 ? 's' : ''}.`);\r\n\r\n      // Increment completed cards count\r\n      const newCompletedCount = cardsCompletedToday + 1;\r\n      setCardsCompletedToday(newCompletedCount);\r\n\r\n      // Save updated completed count to localStorage\r\n      localStorage.setItem(`flashcard_completed_today_${userId}`, newCompletedCount.toString());\r\n\r\n      // Mark that a card was just completed (for auto-advance logic)\r\n      // This is passed to the useFlashcards hook to prevent auto-advance without user activity\r\n      if (window.flashcardHook && window.flashcardHook.setLastCardCompletionTime) {\r\n        window.flashcardHook.setLastCardCompletionTime(Date.now());\r\n      }\r\n      \r\n      // Track card completion time for App.js auto-advance logic\r\n      setLastCardCompletion(Date.now());\r\n      \r\n      // Increment category-specific completed count\r\n      const cardCategory = card.category || 'Uncategorized';\r\n      const cardSubCategory = card.sub_category && card.sub_category.trim() ? card.sub_category : 'Uncategorized';\r\n      const subCategoryKey = `${cardCategory}::${cardSubCategory}`;\r\n      \r\n      const newCategoryCompleted = { ...categoryCompletedCounts };\r\n      const newSubCategoryCompleted = { ...subCategoryCompletedCounts };\r\n      \r\n      newCategoryCompleted[cardCategory] = (newCategoryCompleted[cardCategory] || 0) + 1;\r\n      newSubCategoryCompleted[subCategoryKey] = (newSubCategoryCompleted[subCategoryKey] || 0) + 1;\r\n      \r\n      setCategoryCompletedCounts(newCategoryCompleted);\r\n      setSubCategoryCompletedCounts(newSubCategoryCompleted);\r\n\r\n      // Save updated completion counts to localStorage\r\n      localStorage.setItem(`flashcard_category_completed_${userId}`, JSON.stringify(newCategoryCompleted));\r\n      localStorage.setItem(`flashcard_subcategory_completed_${userId}`, JSON.stringify(newSubCategoryCompleted));\r\n      \r\n      if (userId) {\r\n        localStorage.setItem(`flashcard_completed_today_${userId}`, newCompletedCount.toString());\r\n        localStorage.setItem(`flashcard_category_completed_${userId}`, JSON.stringify(newCategoryCompleted));\r\n        localStorage.setItem(`flashcard_subcategory_completed_${userId}`, JSON.stringify(newSubCategoryCompleted));\r\n      }\r\n      \r\n      // Hide answer and move to next card\r\n      setShowAnswer(false);\r\n      \r\n      // Let the filtering effect handle navigation automatically, but add a backup\r\n      // The useFlashcards hook should detect that the current card is no longer available\r\n      // and automatically move to the next card via smart index management\r\n      // console.log('üîÑ Card review completed, waiting for automatic navigation...');\r\n\r\n      // Force navigation to next card after a brief delay\r\n      setTimeout(() => {\r\n        // console.log('üîÑ FORCING NAVIGATION: Moving to next card');\r\n        nextCard();\r\n      }, 100);\r\n      \r\n      clearMessage();\r\n      \r\n    } catch (error) {\r\n      console.error('‚ùå Error reviewing card:', error);\r\n      console.error('Card ID:', card.id);\r\n      console.error('Rating:', rating);\r\n      setError(`Failed to update card review: ${error.message}`);\r\n    }\r\n  })"
            }
          }
        ]
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'requestRetention' is assigned a value but never used.",
        "line": 796,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 796,
        "endColumn": 25
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'currentCard' is assigned a value but never used.",
        "line": 1032,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 1032,
        "endColumn": 24
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "The 'handleEditCard' function makes the dependencies of useEffect Hook (at line 1881) change on every render. To fix this, wrap the definition of 'handleEditCard' in its own useCallback() Hook.",
        "line": 1166,
        "column": 9,
        "nodeType": "VariableDeclarator",
        "endLine": 1170,
        "endColumn": 4,
        "suggestions": [
          {
            "desc": "Wrap the definition of 'handleEditCard' in its own useCallback() Hook.",
            "fix": {
              "range": [
                46373,
                46480
              ],
              "text": "useCallback((card) => {\r\n    setEditCardData(card);\r\n    setIsEditingCard(true);\r\n    setShowCreateCardForm(true);\r\n  })"
            }
          }
        ]
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'truncatedExplanation' is assigned a value but never used.",
        "line": 1413,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 1413,
        "endColumn": 35
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'subCategoryStats'. Either include it or remove the dependency array.",
        "line": 1981,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 1981,
        "endColumn": 73,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [userId, allDueCards.length, categoryStats, getAllSubCategoryStats, subCategoryStats]",
            "fix": {
              "range": [
                76475,
                76542
              ],
              "text": "[userId, allDueCards.length, categoryStats, getAllSubCategoryStats, subCategoryStats]"
            }
          }
        ]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'cardsDueToday' and 'pastDueCards'. Either include them or remove the dependency array.",
        "line": 2105,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 2105,
        "endColumn": 190,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [pastDueCards.length, cardsDueToday.length, allDueCards.length, filteredDueCards.length, filteredFlashcards.length, showDueTodayOnly, selectedCategory, selectedSubCategory, flashcards, pastDueCards, cardsDueToday]",
            "fix": {
              "range": [
                81669,
                81853
              ],
              "text": "[pastDueCards.length, cardsDueToday.length, allDueCards.length, filteredDueCards.length, filteredFlashcards.length, showDueTodayOnly, selectedCategory, selectedSubCategory, flashcards, pastDueCards, cardsDueToday]"
            }
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 14,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect, useMemo, useCallback } from 'react';\r\nimport { initializeApp } from 'firebase/app';\r\n\r\n// Components\r\nimport LoginScreen from './LoginScreen.jsx';\r\nimport FlashcardDisplay from './components/FlashcardDisplay';\r\nimport FlashcardForm from './components/FlashcardForm';\r\nimport SettingsModal from './components/SettingsModal';\r\nimport ImportExportModal from './components/ImportExportModal';\r\nimport GenerateQuestionsModal from './components/GenerateQuestionsModal';\r\nimport ManageCardsModal from './components/ManageCardsModal';\r\nimport Calendar from './Calendar';\r\nimport RichTextEditor from './RichTextEditor';\r\n\r\n// Hooks\r\nimport { useAuth } from './hooks/useAuth';\r\nimport { useFlashcards } from './hooks/useFlashcards';\r\nimport { useSettings } from './hooks/useSettings';\r\n\r\n// Utils and Constants\r\nimport { SUCCESS_MESSAGES, ERROR_MESSAGES, DEFAULT_FSRS_PARAMS } from './utils/constants';\r\nimport { debugFirestore, checkFirestoreRules } from './debug/utils/firebaseDebug';\r\nimport { debugDueCards } from './debug/utils/debugDueCards';\r\nimport { addDebugAutoAdvanceToWindow } from './debug/utils/debugAutoAdvance';\r\nimport { addDebugCountingToWindow } from './debug/utils/debugCounting';\r\nimport { debugCategories } from './debug/utils/debugCategories';\r\nimport { debugAmazonLP } from './debug/utils/debugAmazonLP';\r\nimport { debugAllCount } from './debug/utils/debugAllCount';\r\nimport { debugCategorySubcategoryMismatch } from './debug/utils/debugCategorySubcategoryMismatch';\r\nimport { debugEmptyCategories } from './debug/utils/debugEmptyCategories';\r\nimport { debugDueCardsSync } from './debug/utils/debugDueCardsSync';\r\nimport { debugQuiet } from './debug/utils/debugQuiet';\r\nimport { fixDueCardsCount } from './debug/utils/fixDueCardsCount';\r\nimport { makeCategoryDueNow, makeAWSDueNow } from './debug/utils/makeCategoryDueNow';\r\nimport './debug/utils/testAutoAdvance'; // Adds window.testAutoAdvance() function\r\n\r\n// Styles\r\nimport './App.css';\r\nimport './ai-explanation-dropdown.css';\r\n\r\n// Firebase configuration\r\nconst firebaseConfig = {\r\n  apiKey: \"AIzaSyC3R7pV3mXqg2-kY9xvH126BoF5KQDQDls\",\r\n  authDomain: \"flashcard-app-3f2a3.firebaseapp.com\",\r\n  projectId: \"flashcard-app-3f2a3\",\r\n  storageBucket: \"flashcard-app-3f2a3.firebasestorage.app\",\r\n  messagingSenderId: \"399745541062\",\r\n  appId: \"1:399745541062:web:958a2cfbd7c6c9c78988c7\",\r\n  measurementId: \"G-6LJ19R2ZTZ\"\r\n};\r\n\r\n/**\r\n * Component that automatically navigates to the optimal category and subcategory\r\n * when no cards are available in the current selection\r\n */\r\nconst AutoNavigateToOptimalCards = ({\r\n  currentCategory,\r\n  currentSubCategory,\r\n  showDueTodayOnly,\r\n  getNextCategoryWithLeastCards,\r\n  getNextSubCategoryWithLeastCards,\r\n  setSelectedCategory,\r\n  setSelectedSubCategory,\r\n  setMessage\r\n}) => {\r\n  const [isNavigating, setIsNavigating] = useState(false);\r\n  const [navigationComplete, setNavigationComplete] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (!showDueTodayOnly || isNavigating || navigationComplete) return;\r\n\r\n    const performAutoNavigation = async () => {\r\n      setIsNavigating(true);\r\n      \r\n      // Step 1: Find the category with the least total cards that has due cards\r\n      const bestCategory = getNextCategoryWithLeastCards(currentCategory);\r\n      \r\n      if (bestCategory) {\r\n        console.log(`üöÄ AUTO-NAVIGATE: Found optimal category: \"${bestCategory}\"`);\r\n        \r\n        // Step 2: Within that category, find the subcategory with least total cards that has due cards\r\n        const bestSubCategory = getNextSubCategoryWithLeastCards(bestCategory, 'All');\r\n        \r\n        if (bestSubCategory) {\r\n          console.log(`üöÄ AUTO-NAVIGATE: Found optimal subcategory: \"${bestSubCategory}\" in category \"${bestCategory}\"`);\r\n          \r\n          // Navigate to the optimal category and subcategory\r\n          setSelectedCategory(bestCategory);\r\n          setSelectedSubCategory(bestSubCategory);\r\n          setMessage(`Auto-navigated to \"${bestCategory}\" ‚Üí \"${bestSubCategory}\" (optimal study path)`);\r\n          \r\n          setTimeout(() => setMessage(''), 4000);\r\n        } else {\r\n          console.log(`üöÄ AUTO-NAVIGATE: No subcategories with due cards in \"${bestCategory}\", showing all subcategories`);\r\n          \r\n          // Navigate to the category but show all subcategories\r\n          setSelectedCategory(bestCategory);\r\n          setSelectedSubCategory('All');\r\n          setMessage(`Auto-navigated to \"${bestCategory}\" category (optimal study path)`);\r\n          \r\n          setTimeout(() => setMessage(''), 4000);\r\n        }\r\n        \r\n        setNavigationComplete(true);\r\n      } else {\r\n        console.log('üöÄ AUTO-NAVIGATE: No categories with due cards found');\r\n        setNavigationComplete(true);\r\n      }\r\n      \r\n      setIsNavigating(false);\r\n    };\r\n\r\n    // Add a small delay to prevent immediate navigation\r\n    const timer = setTimeout(performAutoNavigation, 1000);\r\n    return () => clearTimeout(timer);\r\n  }, [currentCategory, currentSubCategory, showDueTodayOnly, isNavigating, navigationComplete, getNextCategoryWithLeastCards, getNextSubCategoryWithLeastCards, setMessage, setSelectedCategory, setSelectedSubCategory]);\r\n\r\n  if (isNavigating) {\r\n    return (\r\n      <>\r\n        <h2>Finding optimal study path...</h2>\r\n        <div className=\"loading-spinner\" style={{ margin: '2rem auto' }}></div>\r\n        <p>Looking for the category and subcategory with the fewest cards to maximize your progress.</p>\r\n      </>\r\n    );\r\n  }\r\n\r\n  if (navigationComplete) {\r\n    return (\r\n      <>\r\n        <h2>No cards available in current selection</h2>\r\n        <p>\r\n          No cards found in \"{currentCategory}\" category\r\n          {currentSubCategory !== 'All' ? ` ‚Üí \"${currentSubCategory}\" subcategory` : ''}\r\n          {showDueTodayOnly ? ' that are due today' : ''}.\r\n        </p>\r\n        <p>\r\n          <strong>Auto-navigation has been attempted.</strong> If you're still seeing this message, \r\n          there may be no due cards available in any category/subcategory combination.\r\n        </p>\r\n      </>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <h2>Preparing optimal study session...</h2>\r\n      <p>Analyzing your flashcards to find the best starting point...</p>\r\n    </>\r\n  );\r\n};\r\n\r\n/**\r\n * Main App component for the flashcard application\r\n */\r\nfunction App() {\r\n  // Firebase app initialization\r\n  const [firebaseApp, setFirebaseApp] = useState(null);\r\n  const [isFirebaseInitialized, setIsFirebaseInitialized] = useState(false);\r\n\r\n  // Authentication state\r\n  const [showLoginScreen, setShowLoginScreen] = useState(true);\r\n  const [email, setEmail] = useState('');\r\n  const [password, setPassword] = useState('');\r\n\r\n  // UI Modal states\r\n  const [showSettingsModal, setShowSettingsModal] = useState(false);\r\n  const [showCreateCardForm, setShowCreateCardForm] = useState(false);\r\n  const [showImportExportModal, setShowImportExportModal] = useState(false);\r\n  const [showCalendarModal, setShowCalendarModal] = useState(false);\r\n  const [showGenerateModal, setShowGenerateModal] = useState(false);\r\n  const [showManageCardsModal, setShowManageCardsModal] = useState(false);\r\n\r\n  // Edit card states\r\n  const [isEditingCard, setIsEditingCard] = useState(false);\r\n  const [editCardData, setEditCardData] = useState(null);\r\n\r\n  // Mobile header collapse state\r\n  const [isHeaderCollapsed, setIsHeaderCollapsed] = useState(false);\r\n\r\n  // Window management states\r\n  const [isMaximized, setIsMaximized] = useState(false);\r\n  const [isPopouted, setIsPopouted] = useState(false);\r\n  const [windowPosition, setWindowPosition] = useState({ \r\n    x: Math.max(0, (window.innerWidth - 1400) / 2), \r\n    y: Math.max(0, (window.innerHeight - 900) / 2) \r\n  });\r\n  const [windowSize, setWindowSize] = useState({ width: 1400, height: 900 });\r\n  const [isDragging, setIsDragging] = useState(false);\r\n  const [isResizing, setIsResizing] = useState(false);\r\n  const [resizeDirection, setResizeDirection] = useState('');\r\n  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });\r\n  const [resizeStart, setResizeStart] = useState({ x: 0, y: 0, width: 0, height: 0 });\r\n  \r\n  // Notes window drag states\r\n  const [isNotesDragging, setIsNotesDragging] = useState(false);\r\n  const [isNotesResizing, setIsNotesResizing] = useState(false);\r\n  const [notesResizeDirection, setNotesResizeDirection] = useState('');\r\n  const [notesDragOffset, setNotesDragOffset] = useState({ x: 0, y: 0 });\r\n  const [notesResizeStart, setNotesResizeStart] = useState({ x: 0, y: 0, width: 0, height: 0 });\r\n\r\n  // Message states\r\n  const [message, setMessage] = useState('');\r\n  const [error, setError] = useState('');\r\n\r\n  // AI Generation states\r\n  const [apiKeys, setApiKeys] = useState({\r\n    openai: localStorage.getItem('openai_api_key') || '',\r\n    anthropic: localStorage.getItem('anthropic_api_key') || '',\r\n    gemini: localStorage.getItem('gemini_api_key') || ''\r\n  });\r\n  const [selectedProvider, setSelectedProvider] = useState(localStorage.getItem('selected_ai_provider') || 'openai');\r\n\r\n  // Session-wide notes states\r\n  const [notes, setNotes] = useState(() => localStorage.getItem('flashcard_session_notes') || '');\r\n  const [notesCopied, setNotesCopied] = useState(false);\r\n  const [notesSaved, setNotesSaved] = useState(false);\r\n\r\n  // Streak tracking state\r\n  const [streakDays, setStreakDays] = useState(0);\r\n  \r\n  // Track if we've checked for default cards creation\r\n  const [hasCheckedForDefaults, setHasCheckedForDefaults] = useState(false);\r\n  \r\n  // Track if anonymous warning has been dismissed\r\n  const [isAnonymousWarningDismissed, setIsAnonymousWarningDismissed] = useState(false);\r\n  \r\n  // Track initial due cards count for the day\r\n  const [initialDueCardsCount, setInitialDueCardsCount] = useState(0);\r\n  const [cardsCompletedToday, setCardsCompletedToday] = useState(0);\r\n  const [initialCategoryStats, setInitialCategoryStats] = useState({});\r\n  const [categoryCompletedCounts, setCategoryCompletedCounts] = useState({});\r\n  const [initialSubCategoryStats, setInitialSubCategoryStats] = useState({});\r\n  const [subCategoryCompletedCounts, setSubCategoryCompletedCounts] = useState({});\r\n  const [lastManualCategoryChange, setLastManualCategoryChange] = useState(0);\r\n  const [lastManualSubCategoryChange, setLastManualSubCategoryChange] = useState(0);\r\n  const [lastCardCompletion, setLastCardCompletion] = useState(0);\r\n  const [isManualCategorySelection, setIsManualCategorySelection] = useState(false);\r\n\r\n  // Category selection state - managed in App.js to avoid circular dependency\r\n  const [selectedCategory, setSelectedCategory] = useState('All');\r\n  \r\n  // Collapsible sections state - auto-collapse on mobile\r\n  const [isCategoriesCollapsed, setIsCategoriesCollapsed] = useState(window.innerWidth <= 768);\r\n  const [isSubCategoriesCollapsed, setIsSubCategoriesCollapsed] = useState(window.innerWidth <= 768);\r\n  const [isLevelsCollapsed, setIsLevelsCollapsed] = useState(window.innerWidth <= 768);\r\n  const [isNotesCollapsed, setIsNotesCollapsed] = useState(window.innerWidth <= 768);\r\n  const [isNotesPopouted, setIsNotesPopouted] = useState(false);\r\n  const [notesWindowPosition, setNotesWindowPosition] = useState({ x: 100, y: 100 });\r\n  const [notesWindowSize, setNotesWindowSize] = useState({ width: 600, height: 700 });\r\n  \r\n  // Explain functionality state\r\n  const [showExplainModal, setShowExplainModal] = useState(false);\r\n  const [explainPrompt, setExplainPrompt] = useState('');\r\n  const [isGeneratingExplanation, setIsGeneratingExplanation] = useState(false);\r\n  const [explainError, setExplainError] = useState('');\r\n  const [addExplanationToQuestion, setAddExplanationToQuestion] = useState(true);\r\n  \r\n\r\n\r\n  // Initialize Firebase\r\n  useEffect(() => {\r\n    try {\r\n      const app = initializeApp(firebaseConfig);\r\n      setFirebaseApp(app);\r\n      setIsFirebaseInitialized(true);\r\n    } catch (error) {\r\n      console.error('Firebase initialization failed:', error);\r\n      setError('Failed to initialize application');\r\n    }\r\n  }, []);\r\n\r\n  // Initialize hooks\r\n  const {\r\n    userId,\r\n    userDisplayName,\r\n    isAnonymous,\r\n    isAuthReady,\r\n    authError,\r\n    isLoading: authLoading,\r\n    signInAnonymouslyUser,\r\n    signInWithEmail,\r\n    createUserWithEmail,\r\n    signOutUser,\r\n    sendPasswordReset,\r\n    clearAuthError\r\n  } = useAuth(firebaseApp);\r\n\r\n  const {\r\n    flashcards,\r\n    filteredFlashcards,\r\n    currentCardIndex,\r\n    showAnswer,\r\n    selectedSubCategory,\r\n    selectedLevel,\r\n    showDueTodayOnly,\r\n    showStarredOnly,\r\n    isLoading: flashcardsLoading,\r\n    error: flashcardsError,\r\n    getCurrentCard,\r\n    getCategories,\r\n    getSubCategories,\r\n    getSubCategoryStats,\r\n    getAllSubCategoryStats,\r\n    getLevels,\r\n    getCategoryStats,\r\n    getCardsDueToday,\r\n    getPastDueCards,\r\n    getAllDueCards,\r\n    getFilteredDueCards,\r\n    getCardsReviewedToday,\r\n    setShowAnswer,\r\n    setSelectedSubCategory,\r\n    setSelectedLevel,\r\n    setShowDueTodayOnly,\r\n    setShowStarredOnly,\r\n    setCurrentCardIndex,\r\n    nextCard,\r\n    prevCard,\r\n    addToNavigationHistory,\r\n    getNextCategoryWithDueCards,\r\n    getNextCategoryWithLeastCards,\r\n    getNextSubCategoryWithLeastCards,\r\n    addFlashcard,\r\n    updateFlashcard,\r\n    deleteFlashcard,\r\n    bulkImportFlashcards,\r\n    toggleStarCard,\r\n    clearError: clearFlashcardsError,\r\n    // Debug functions\r\n    manualTriggerAutoAdvance,\r\n    debugCurrentFilterState,\r\n    debugSubCategoryTracking\r\n  } = useFlashcards(firebaseApp, userId);\r\n\r\n  const {\r\n    isDarkMode,\r\n    fsrsParams,\r\n    showIntervalSettings,\r\n    settingsLoaded,\r\n    isLoading: settingsLoading,\r\n    error: settingsError,\r\n    toggleDarkMode,\r\n    updateFsrsParams,\r\n    toggleIntervalSettings,\r\n    clearError: clearSettingsError\r\n  } = useSettings(firebaseApp, userId);\r\n\r\n  // Get computed values (must be before any useEffect that uses them)\r\n  const categoryStats = getCategoryStats();\r\n  const currentCard = getCurrentCard();\r\n  const categories = getCategories();\r\n  const subCategories = getSubCategories(selectedCategory);\r\n  \r\n  // Debug subcategories when they change\r\n  React.useEffect(() => {\r\n    console.log('üîç App.js subCategories updated:', {\r\n      selectedCategory,\r\n      subCategories,\r\n      subCategoriesLength: subCategories.length\r\n    });\r\n  }, [selectedCategory, subCategories]);\r\n  const subCategoryStats = getSubCategoryStats(selectedCategory);\r\n  const levels = getLevels();\r\n\r\n  // Get all categories (not filtered by due date) as fallback\r\n  const allCategories = useMemo(() => {\r\n    const activeCards = flashcards.filter(card => card.active !== false);\r\n    return [...new Set(activeCards.map(card => card.category || 'Uncategorized'))];\r\n  }, [flashcards]);\r\n\r\n  // Use categories from due filter, or all categories if showing all cards\r\n  const displayCategories = useMemo(() => {\r\n    if (showDueTodayOnly) {\r\n      // In due today mode, use real-time categories from the hook\r\n      // The filtering below will determine which ones actually show\r\n      return categories;\r\n    } else {\r\n      // In all cards mode, show all categories\r\n      return allCategories;\r\n    }\r\n  }, [categories, showDueTodayOnly, allCategories]);\r\n  \r\n  // Filter displayCategories to only include categories with actual cards using same logic as individual buttons\r\n  const filteredDisplayCategories = useMemo(() => {\r\n    // Create special debug function for AWS category\r\n    window.debugAWSCards = () => {\r\n      const allCards = flashcards || [];\r\n      const awsCards = allCards.filter(card => {\r\n        const category = (card.category || '').toLowerCase();\r\n        return category === 'aws';\r\n      });\r\n      \r\n      const awsInCategories = (categories || []).includes('AWS');\r\n      const awsInDisplayCategories = (displayCategories || []).includes('AWS');\r\n      const awsInFiltered = (filteredDisplayCategories || []).includes('AWS');\r\n      \r\n      // console.log(`AWS Debug: ${awsCards.length} cards found, visible: ${awsInFiltered}`);\r\n      \r\n      return { awsCards, awsInCategories, awsInDisplayCategories, awsInFiltered };\r\n    };\r\n    \r\n    // Helper function to count cards in a category with current filters\r\n    const getCardCountInCategory = (category) => {\r\n      // Always use real-time counting - this ensures categories with actual due cards show up\r\n      let categoryCards = flashcards.filter(card => {\r\n        // Only count active cards\r\n        if (card.active === false) return false;\r\n        // Match the category\r\n        return (card.category || 'Uncategorized') === category;\r\n      });\r\n      \r\n      // Apply filters based on current mode\r\n      if (showDueTodayOnly && showStarredOnly) {\r\n        // When both filters are on, count actual starred due cards\r\n        categoryCards = categoryCards.filter(card => card.starred === true);\r\n        \r\n        const now = new Date();\r\n        const endOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);\r\n        categoryCards = categoryCards.filter(card => {\r\n          let dueDate = card.dueDate || new Date(0);\r\n          if (dueDate && typeof dueDate.toDate === 'function') {\r\n            dueDate = dueDate.toDate();\r\n          }\r\n          return dueDate < endOfToday;\r\n        });\r\n      } else if (showDueTodayOnly) {\r\n        // Filter by due date only - use end of today like useFlashcards\r\n        const now = new Date();\r\n        const endOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);\r\n        categoryCards = categoryCards.filter(card => {\r\n          let dueDate = card.dueDate || new Date(0);\r\n          if (dueDate && typeof dueDate.toDate === 'function') {\r\n            dueDate = dueDate.toDate();\r\n          }\r\n          return dueDate < endOfToday;\r\n        });\r\n      } else if (showStarredOnly) {\r\n        // Filter by starred only\r\n        categoryCards = categoryCards.filter(card => card.starred === true);\r\n      }\r\n      \r\n      return categoryCards.length;\r\n    };\r\n    \r\n    // Filter displayCategories to only include categories with actual cards\r\n    const filteredCategories = displayCategories.filter(category => {\r\n      const cardCount = getCardCountInCategory(category);\r\n      return cardCount > 0;\r\n    });\r\n    \r\n    return filteredCategories;\r\n  }, [displayCategories, flashcards, showDueTodayOnly, showStarredOnly, categories]);\r\n\r\n  // Initialize debug utilities (development only)\r\n  useEffect(() => {\r\n    if (flashcards && userId && manualTriggerAutoAdvance && debugCurrentFilterState && debugSubCategoryTracking) {\r\n      const flashcardHook = {\r\n        flashcards,\r\n        filteredFlashcards,\r\n        selectedCategory,\r\n        selectedSubCategory,\r\n        selectedLevel,\r\n        showDueTodayOnly,\r\n        manualTriggerAutoAdvance,\r\n        debugCurrentFilterState,\r\n        debugSubCategoryTracking,\r\n        getSubCategories,\r\n        getSubCategoryStats\r\n      };\r\n      addDebugAutoAdvanceToWindow(flashcardHook);\r\n      \r\n      // Add counting debug utilities\r\n      addDebugCountingToWindow(flashcards, userId, categoryStats, getSubCategoryStats(), selectedCategory);\r\n      \r\n      // Add category debug utility to window (but don't call it automatically)\r\n      window.debugCategories = () => debugCategories(flashcards);\r\n      window.debugAmazonLP = () => debugAmazonLP(flashcards);\r\n      window.debugCategorySubcategoryMismatch = () => debugCategorySubcategoryMismatch(flashcards, showDueTodayOnly, selectedCategory);\r\n      window.debugEmptyCategories = () => debugEmptyCategories(flashcards, showDueTodayOnly, showStarredOnly, filteredDisplayCategories, initialCategoryStats, categoryCompletedCounts);\r\n      window.debugQuiet = () => debugQuiet(flashcards, showDueTodayOnly, filteredFlashcards, filteredDisplayCategories);\r\n      window.fixDueCardsCount = fixDueCardsCount;\r\n      window.makeCategoryDueNow = makeCategoryDueNow;\r\n      window.makeAWSDueNow = makeAWSDueNow;\r\n      window.flashcards = flashcards; // Make flashcards available for fix function\r\n      window.updateFlashcard = updateFlashcard; // Make update function available\r\n      \r\n      // Force update of AWS cards to be due now and add a UI refresh trigger\r\n      window.forceAWSUpdate = async () => {\r\n        const now = new Date();\r\n        let updateCount = 0;\r\n        \r\n        const awsCards = flashcards.filter(card => \r\n          (card.category || '').toLowerCase() === 'aws' && \r\n          card.active !== false\r\n        );\r\n        \r\n        for (const card of awsCards) {\r\n          try {\r\n            await updateFlashcard(card.id, { dueDate: now });\r\n            updateCount++;\r\n          } catch (err) {\r\n            console.error('Failed to update AWS card:', err);\r\n          }\r\n        }\r\n        \r\n        // Force UI refresh\r\n        if (showDueTodayOnly) {\r\n          setShowDueTodayOnly(false);\r\n          setTimeout(() => setShowDueTodayOnly(true), 500);\r\n        } else {\r\n          setShowDueTodayOnly(true);\r\n        }\r\n        \r\n        // console.log(`AWS Update: ${updateCount}/${awsCards.length} cards updated`);\r\n        return { updated: updateCount, total: awsCards.length };\r\n      };\r\n      \r\n      // Add the regular auto-run AWS update but with UI refresh\r\n      setTimeout(async () => {\r\n        const hasAWSCards = flashcards.some(card => card.category === 'AWS' && card.active !== false);\r\n        const awsInCategories = categories.includes('AWS');\r\n        \r\n        if (hasAWSCards && !awsInCategories && showDueTodayOnly) {\r\n          window.forceAWSUpdate();\r\n        }\r\n      }, 2000); // Wait 2 seconds for everything to load\r\n      // Calculate displayCategories and dailyProgress for debug function - using consistent real-time counting\r\n      const debugDisplayCategories = categories.length > 0 ? categories : (!showDueTodayOnly ? allCategories : []);\r\n      const dailyProgress = {\r\n        completedToday: cardsCompletedToday,\r\n        dueToday: cardsDueToday.length, // Use real-time count for consistency\r\n        totalToday: cardsCompletedToday + cardsDueToday.length\r\n      };\r\n      window.debugAllCount = () => debugAllCount(flashcards, showDueTodayOnly, showStarredOnly, selectedCategory, debugDisplayCategories, initialCategoryStats, categoryCompletedCounts);\r\n      window.debugDueCardsSync = () => debugDueCardsSync(flashcards, showDueTodayOnly, filteredFlashcards, dailyProgress, filteredDisplayCategories);\r\n\r\n      // Force refresh categories function for debugging\r\n      window.forceRefreshCategories = () => {\r\n        console.log('üîÑ Force refreshing categories...');\r\n\r\n        // Force re-render by updating a dummy state\r\n        setMessage('Refreshing categories...');\r\n        setTimeout(() => setMessage(''), 1000);\r\n\r\n        // Log current state\r\n        console.log('Current flashcards:', flashcards.length);\r\n        console.log('Current categories:', categories);\r\n\r\n        // Force recalculation if getCategories is available\r\n        if (getCategories) {\r\n          const newCategories = getCategories();\r\n          console.log('Recalculated categories:', newCategories);\r\n        }\r\n\r\n        // Force page refresh as last resort\r\n        console.log('If categories still don\\'t appear, try: window.location.reload()');\r\n      };\r\n\r\n      // Debug subcategory filtering issues\r\n      window.debugSubcategoryFiltering = () => {\r\n        console.log('üîç SUBCATEGORY FILTERING DEBUG');\r\n        console.log('='.repeat(40));\r\n\r\n        console.log('Current state:', {\r\n          selectedCategory,\r\n          selectedSubCategory,\r\n          showDueTodayOnly,\r\n          showStarredOnly\r\n        });\r\n\r\n        if (selectedCategory === 'All') {\r\n          console.log('‚ö†Ô∏è Category is \"All\" - subcategories should show from all categories');\r\n        } else {\r\n          const categoryCards = flashcards.filter(card =>\r\n            card.active !== false && card.category === selectedCategory\r\n          );\r\n\r\n          console.log(`Cards in \"${selectedCategory}\":`, categoryCards.length);\r\n\r\n          const allSubCats = [...new Set(\r\n            categoryCards.map(card => card.sub_category || 'Uncategorized')\r\n          )];\r\n\r\n          console.log('All subcategories in category:', allSubCats);\r\n          console.log('Filtered subcategories showing:', subCategories);\r\n\r\n          // Check each subcategory\r\n          allSubCats.forEach(subCat => {\r\n            const subCatCards = categoryCards.filter(card =>\r\n              (card.sub_category || 'Uncategorized') === subCat\r\n            );\r\n\r\n            let filteredSubCatCards = subCatCards;\r\n\r\n            if (showDueTodayOnly) {\r\n              const now = new Date();\r\n              const endOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);\r\n              filteredSubCatCards = filteredSubCatCards.filter(card => {\r\n                let dueDate = card.dueDate || new Date(0);\r\n                if (dueDate && typeof dueDate.toDate === 'function') {\r\n                  dueDate = dueDate.toDate();\r\n                }\r\n                return dueDate < endOfToday;\r\n              });\r\n            }\r\n\r\n            if (showStarredOnly) {\r\n              filteredSubCatCards = filteredSubCatCards.filter(card => card.starred === true);\r\n            }\r\n\r\n            const shouldShow = filteredSubCatCards.length > 0;\r\n            const isShowing = subCategories.includes(subCat);\r\n            const status = shouldShow === isShowing ? '‚úÖ' : '‚ùå';\r\n\r\n            console.log(`${status} \"${subCat}\": ${filteredSubCatCards.length} cards (should ${shouldShow ? 'show' : 'hide'}, is ${isShowing ? 'showing' : 'hidden'})`);\r\n          });\r\n        }\r\n      };\r\n\r\n      // Add hook functions to window for communication between App.js and useFlashcards.js\r\n      window.flashcardHook = {\r\n        selectedCategory: selectedCategory,\r\n        selectedSubCategory: selectedSubCategory,\r\n        setLastCardCompletionTime: (timestamp) => {\r\n          // This will be called from App.js when a card is completed\r\n          // console.log('üîÑ Card completion timestamp set:', timestamp);\r\n        },\r\n        onSubCategoryAutoAdvance: (newSubCategory) => {\r\n          // This will be called from useFlashcards.js when auto-advancing to next subcategory\r\n          console.log(`üîÑ APP.JS: Received subcategory auto-advance signal, switching to \"${newSubCategory}\"`);\r\n          setSelectedSubCategory(newSubCategory);\r\n        }\r\n      };\r\n\r\n      // Log category debug info once when flashcards change\r\n      if (flashcards && flashcards.length > 0 && !window._hasLoggedCategories) {\r\n        // console.log('\\nüîç CATEGORY DEBUG - Check terminal for details\\n');\r\n        debugCategories(flashcards);\r\n        window._hasLoggedCategories = true;\r\n      }\r\n    }\r\n  }, [flashcards, userId, filteredFlashcards, selectedCategory, selectedSubCategory, selectedLevel, showDueTodayOnly]);\r\n\r\n  // Sync login screen visibility with authentication state\r\n  useEffect(() => {\r\n    if (isAuthReady) {\r\n      if (userId) {\r\n        // User is authenticated, hide login screen\r\n        setShowLoginScreen(false);\r\n        // console.log('User authenticated, hiding login screen');\r\n        // Reset the default cards check for this new user\r\n        setHasCheckedForDefaults(false);\r\n        // Reset anonymous warning dismissal for new user\r\n        setIsAnonymousWarningDismissed(false);\r\n      } else {\r\n        // No user, show login screen\r\n        setShowLoginScreen(true);\r\n        // console.log('No user found, showing login screen');\r\n        // Reset the check when logging out\r\n        setHasCheckedForDefaults(false);\r\n        // Reset anonymous warning dismissal when logging out\r\n        setIsAnonymousWarningDismissed(false);\r\n      }\r\n    }\r\n  }, [isAuthReady, userId]);\r\n\r\n  // Debug: Monitor selectedCategory changes - DISABLED\r\n  // useEffect(() => {\r\n  //   console.log('üîç selectedCategory changed to:', selectedCategory);\r\n  // }, [selectedCategory]);\r\n\r\n  // Create default flashcards for new users\r\n  useEffect(() => {\r\n    // console.log('üîç Default cards useEffect triggered:', {\r\n    //   isAuthReady,\r\n    //   userId,\r\n    //   hasAddFlashcard: !!addFlashcard,\r\n    //   flashcardsLength: flashcards.length,\r\n    //   hasCheckedForDefaults\r\n    // });\r\n    \r\n    // Only run when user is authenticated, we have the addFlashcard function, and we haven't checked yet\r\n    if (isAuthReady && userId && addFlashcard && !hasCheckedForDefaults) {\r\n      // console.log('üîç Conditions met, setting timer for default card creation');\r\n      setHasCheckedForDefaults(true); // Mark that we've checked to prevent multiple runs\r\n      \r\n      // Small delay to ensure Firestore listener has had time to populate flashcards\r\n      const timer = setTimeout(() => {\r\n        // console.log('üîç Timer fired, calling createDefaultFlashcards');\r\n        createDefaultFlashcards(userId);\r\n      }, 2000); // Increased to 2 seconds\r\n      \r\n      return () => {\r\n        // console.log('üîç Cleaning up timer');\r\n        clearTimeout(timer);\r\n      };\r\n    }\r\n  }, [isAuthReady, userId, addFlashcard, flashcards.length, hasCheckedForDefaults]);\r\n\r\n  // Handle authentication\r\n  const handleLogin = async (loginType, emailVal = '', passwordVal = '') => {\r\n    clearAuthError();\r\n    setError('');\r\n\r\n    try {\r\n      switch (loginType) {\r\n        case 'anonymous':\r\n          await signInAnonymouslyUser();\r\n          break;\r\n        case 'login':\r\n          await signInWithEmail(emailVal, passwordVal);\r\n          break;\r\n        case 'register':\r\n          await createUserWithEmail(emailVal, passwordVal);\r\n          break;\r\n        default:\r\n          throw new Error('Invalid login type');\r\n      }\r\n      // setShowLoginScreen(false); // This will be handled by the useEffect\r\n    } catch (error) {\r\n      console.error('Login error:', error);\r\n      setError(error.message || 'Authentication failed');\r\n    }\r\n  };\r\n\r\n  // Handle password reset\r\n  const handlePasswordReset = async (resetEmail) => {\r\n    clearAuthError();\r\n    setError('');\r\n    \r\n    try {\r\n      await sendPasswordReset(resetEmail);\r\n      setMessage('Password reset email sent! Check your inbox.');\r\n    } catch (error) {\r\n      console.error('Password reset error:', error);\r\n      setError(error.message || 'Failed to send password reset email');\r\n    }\r\n  };\r\n\r\n  const handleSignOut = async () => {\r\n    try {\r\n      await signOutUser();\r\n      // setShowLoginScreen(true); // This will be handled by the useEffect\r\n      setEmail('');\r\n      setPassword('');\r\n      // Clear any user-specific state\r\n      setMessage('');\r\n      setError('');\r\n    } catch (error) {\r\n      console.error('Sign out error:', error);\r\n      setError('Failed to sign out');\r\n    }\r\n  };\r\n\r\n  // Handle flashcard operations\r\n  const handleCreateCard = async (cardData) => {\r\n    try {\r\n      await addFlashcard(cardData);\r\n      setMessage(SUCCESS_MESSAGES.CARD_CREATED);\r\n      setShowCreateCardForm(false);\r\n      clearMessage();\r\n    } catch (error) {\r\n      setError(error.message || 'Failed to create flashcard');\r\n    }\r\n  };\r\n\r\n  // Handle review card with FSRS algorithm\r\n  const handleReviewCard = async (rating) => {\r\n    const card = getCurrentCard();\r\n    if (!card) {\r\n      console.error('No current card found for review');\r\n      return;\r\n    }\r\n\r\n    // console.log('üîÑ Reviewing card:', card.id, 'Rating:', rating);\r\n\r\n    try {\r\n      // FSRS algorithm implementation\r\n      const now = new Date();\r\n      let { \r\n        easeFactor = 2.5, \r\n        interval = 1, \r\n        repetitions = 0, \r\n        difficulty = 5, \r\n        stability = 2,\r\n        lastReviewed \r\n      } = card;\r\n      \r\n      // Convert rating to numeric value\r\n      const ratingMap = { again: 1, hard: 2, good: 3, easy: 4 };\r\n      const numRating = ratingMap[rating];\r\n      \r\n      // FSRS parameters from settings\r\n      const { \r\n        requestRetention = 0.9, \r\n        maximumInterval = 36500,\r\n        w = DEFAULT_FSRS_PARAMS.w,\r\n        againFactor = 0.5,\r\n        hardFactor = 0.8,\r\n        goodFactor = 1.0,\r\n        easyFactor = 1.3,\r\n        initialAgainInterval = 1,\r\n        initialHardInterval = 1,\r\n        initialGoodInterval = 4,\r\n        initialEasyInterval = 15\r\n      } = fsrsParams;\r\n      \r\n      // Calculate elapsed days since last review\r\n      const lastReviewDate = lastReviewed ? (lastReviewed.toDate ? lastReviewed.toDate() : new Date(lastReviewed)) : null;\r\n      const elapsedDays = lastReviewDate ? Math.max(1, Math.round((now - lastReviewDate) / (1000 * 60 * 60 * 24))) : 0;\r\n      \r\n      // FSRS-4.5 algorithm implementation\r\n      if (numRating === 1) { // Again\r\n        repetitions = 0;\r\n        \r\n        // For first review or after a lapse\r\n        if (card.repetitions === 0) {\r\n          interval = initialAgainInterval / (24 * 60); // Convert minutes to days\r\n        } else {\r\n          // Use againFactor to reduce the interval\r\n          interval = Math.max(1, Math.round(interval * againFactor));\r\n        }\r\n        \r\n        // Increase difficulty\r\n        difficulty = Math.min(10, difficulty + w[6]);\r\n        \r\n        // Reduce stability significantly\r\n        stability = stability * Math.exp(w[11] * Math.pow(difficulty, w[12]));\r\n        stability = Math.max(0.1, stability);\r\n        \r\n        // Reduce ease factor\r\n        easeFactor = Math.max(1.3, easeFactor - 0.2);\r\n        \r\n      } else if (numRating === 2) { // Hard\r\n        \r\n        if (repetitions === 0) {\r\n          interval = initialHardInterval / (24 * 60); // Convert minutes to days\r\n        } else {\r\n          // Apply hard factor to current interval\r\n          const newInterval = interval * hardFactor;\r\n          // But also consider the actual elapsed time\r\n          interval = Math.max(elapsedDays + 1, Math.round(newInterval));\r\n        }\r\n        \r\n        repetitions++;\r\n        \r\n        // Slightly increase difficulty\r\n        difficulty = Math.min(10, difficulty + w[5] * 0.5);\r\n        \r\n        // Slightly reduce stability\r\n        const recallProbability = Math.exp(-elapsedDays / stability);\r\n        stability = stability * (1 + Math.exp(w[8]) * (11 - difficulty) * Math.pow(stability, w[9]) * (Math.exp(recallProbability * w[10]) - 1));\r\n        \r\n        // Slightly reduce ease factor\r\n        easeFactor = Math.max(1.3, easeFactor - 0.15);\r\n        \r\n      } else if (numRating === 3) { // Good\r\n        \r\n        if (repetitions === 0) {\r\n          interval = initialGoodInterval;\r\n        } else if (repetitions === 1) {\r\n          interval = initialGoodInterval * 1.5;\r\n        } else {\r\n          // Standard interval calculation with goodFactor\r\n          const newInterval = interval * easeFactor * goodFactor;\r\n          interval = Math.round(newInterval);\r\n        }\r\n        \r\n        repetitions++;\r\n        \r\n        // Maintain or slightly reduce difficulty\r\n        difficulty = Math.max(1, difficulty - w[6] * 0.3);\r\n        \r\n        // Increase stability based on successful recall\r\n        const recallProbability = Math.exp(-elapsedDays / stability);\r\n        stability = stability * (1 + Math.exp(w[8]) * (11 - difficulty) * Math.pow(stability, w[9]) * (Math.exp(recallProbability * w[10]) - 1));\r\n        \r\n        // Maintain ease factor\r\n        // easeFactor stays the same\r\n        \r\n      } else if (numRating === 4) { // Easy\r\n        \r\n        if (repetitions === 0) {\r\n          interval = initialEasyInterval;\r\n        } else {\r\n          // Apply easy bonus to interval\r\n          const newInterval = interval * easeFactor * easyFactor;\r\n          interval = Math.round(newInterval);\r\n        }\r\n        \r\n        repetitions++;\r\n        \r\n        // Reduce difficulty\r\n        difficulty = Math.max(1, difficulty - w[7]);\r\n        \r\n        // Increase stability more for easy recall\r\n        const recallProbability = Math.exp(-elapsedDays / stability);\r\n        stability = stability * (1 + Math.exp(w[8]) * (11 - difficulty) * Math.pow(stability, w[9]) * (Math.exp(recallProbability * w[10]) - 1) * 1.3);\r\n        \r\n        // Increase ease factor\r\n        easeFactor = Math.min(2.5, easeFactor + 0.15);\r\n      }\r\n      \r\n      // Apply fuzz factor to prevent cards bunching up\r\n      const fuzzRange = interval * (fsrsParams.fuzzFactor || 0.05);\r\n      const fuzz = (Math.random() - 0.5) * 2 * fuzzRange;\r\n      interval = Math.max(1, Math.round(interval + fuzz));\r\n      \r\n      // Apply maximum interval limit\r\n      interval = Math.min(interval, maximumInterval);\r\n      \r\n      // Calculate next due date\r\n      const dueDate = new Date(now.getTime() + interval * 24 * 60 * 60 * 1000);\r\n      \r\n      // Import Timestamp for proper Firestore format\r\n      const { Timestamp } = await import('firebase/firestore');\r\n      \r\n      const updateData = {\r\n        easeFactor,\r\n        interval,\r\n        repetitions,\r\n        difficulty,\r\n        stability,\r\n        dueDate: Timestamp.fromDate(dueDate),\r\n        lastReviewed: Timestamp.fromDate(now),\r\n        reviewCount: (card.reviewCount || 0) + 1,\r\n        level: rating // Store the rating as the level\r\n      };\r\n      \r\n      // console.log('üìù Updating card with data:', updateData);\r\n      // console.log(`üìÖ Next review: ${interval} days from now (${dueDate.toLocaleDateString()})`);\r\n      \r\n      // Add current card to navigation history before updating it\r\n      // This ensures we can navigate back to this card even if it gets filtered out\r\n      addToNavigationHistory(card);\r\n      \r\n      // Update the card\r\n      await updateFlashcard(card.id, updateData);\r\n\r\n      // console.log('‚úÖ Card review successful!');\r\n      // console.log('üìÖ Card new due date:', dueDate);\r\n      // console.log('üìÖ Is card still due today?', dueDate <= new Date());\r\n      // console.log('üîç Current card ID:', card.id);\r\n      // console.log('üîç Update data applied:', updateData);\r\n\r\n      setMessage(`Card reviewed as ${rating.toUpperCase()}! Next review in ${interval} day${interval !== 1 ? 's' : ''}.`);\r\n\r\n      // Increment completed cards count\r\n      const newCompletedCount = cardsCompletedToday + 1;\r\n      setCardsCompletedToday(newCompletedCount);\r\n\r\n      // Save updated completed count to localStorage\r\n      localStorage.setItem(`flashcard_completed_today_${userId}`, newCompletedCount.toString());\r\n\r\n      // Mark that a card was just completed (for auto-advance logic)\r\n      // This is passed to the useFlashcards hook to prevent auto-advance without user activity\r\n      if (window.flashcardHook && window.flashcardHook.setLastCardCompletionTime) {\r\n        window.flashcardHook.setLastCardCompletionTime(Date.now());\r\n      }\r\n      \r\n      // Track card completion time for App.js auto-advance logic\r\n      setLastCardCompletion(Date.now());\r\n      \r\n      // Increment category-specific completed count\r\n      const cardCategory = card.category || 'Uncategorized';\r\n      const cardSubCategory = card.sub_category && card.sub_category.trim() ? card.sub_category : 'Uncategorized';\r\n      const subCategoryKey = `${cardCategory}::${cardSubCategory}`;\r\n      \r\n      const newCategoryCompleted = { ...categoryCompletedCounts };\r\n      const newSubCategoryCompleted = { ...subCategoryCompletedCounts };\r\n      \r\n      newCategoryCompleted[cardCategory] = (newCategoryCompleted[cardCategory] || 0) + 1;\r\n      newSubCategoryCompleted[subCategoryKey] = (newSubCategoryCompleted[subCategoryKey] || 0) + 1;\r\n      \r\n      setCategoryCompletedCounts(newCategoryCompleted);\r\n      setSubCategoryCompletedCounts(newSubCategoryCompleted);\r\n\r\n      // Save updated completion counts to localStorage\r\n      localStorage.setItem(`flashcard_category_completed_${userId}`, JSON.stringify(newCategoryCompleted));\r\n      localStorage.setItem(`flashcard_subcategory_completed_${userId}`, JSON.stringify(newSubCategoryCompleted));\r\n      \r\n      if (userId) {\r\n        localStorage.setItem(`flashcard_completed_today_${userId}`, newCompletedCount.toString());\r\n        localStorage.setItem(`flashcard_category_completed_${userId}`, JSON.stringify(newCategoryCompleted));\r\n        localStorage.setItem(`flashcard_subcategory_completed_${userId}`, JSON.stringify(newSubCategoryCompleted));\r\n      }\r\n      \r\n      // Hide answer and move to next card\r\n      setShowAnswer(false);\r\n      \r\n      // Let the filtering effect handle navigation automatically, but add a backup\r\n      // The useFlashcards hook should detect that the current card is no longer available\r\n      // and automatically move to the next card via smart index management\r\n      // console.log('üîÑ Card review completed, waiting for automatic navigation...');\r\n\r\n      // Force navigation to next card after a brief delay\r\n      setTimeout(() => {\r\n        // console.log('üîÑ FORCING NAVIGATION: Moving to next card');\r\n        nextCard();\r\n      }, 100);\r\n      \r\n      clearMessage();\r\n      \r\n    } catch (error) {\r\n      console.error('‚ùå Error reviewing card:', error);\r\n      console.error('Card ID:', card.id);\r\n      console.error('Rating:', rating);\r\n      setError(`Failed to update card review: ${error.message}`);\r\n    }\r\n  };\r\n\r\n  const handleUpdateCard = async (cardData, cardId) => {\r\n    try {\r\n      await updateFlashcard(cardId, cardData);\r\n      setMessage(SUCCESS_MESSAGES.CARD_UPDATED);\r\n      setIsEditingCard(false);\r\n      setEditCardData(null);\r\n      clearMessage();\r\n    } catch (error) {\r\n      setError(error.message || 'Failed to update flashcard');\r\n    }\r\n  };\r\n\r\n  const handleDeleteCard = async (cardId) => {\r\n    if (!window.confirm('Are you sure you want to delete this flashcard?')) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // Store current position for smart navigation\r\n      const currentCard = getCurrentCard();\r\n      const currentPosition = currentCardIndex;\r\n      const totalCards = filteredFlashcards.length;\r\n      \r\n      console.log(`üóëÔ∏è Deleting card at position ${currentPosition} of ${totalCards}`);\r\n      \r\n      await deleteFlashcard(cardId);\r\n      \r\n      // Navigate to next available card\r\n      // The filtering system will handle the actual navigation via useEffect\r\n      // But we can help by adjusting the index if we're at the end\r\n      if (currentPosition >= totalCards - 1 && totalCards > 1) {\r\n        // We're deleting the last card, move to the previous one\r\n        setCurrentCardIndex(Math.max(0, currentPosition - 1));\r\n        console.log(`üîÑ Deleted last card, moving to position ${Math.max(0, currentPosition - 1)}`);\r\n      }\r\n      // For other positions, let the filtering system handle navigation automatically\r\n      \r\n      setMessage(SUCCESS_MESSAGES.CARD_DELETED);\r\n      setIsEditingCard(false);\r\n      setEditCardData(null);\r\n      clearMessage();\r\n    } catch (error) {\r\n      setError(error.message || 'Failed to delete flashcard');\r\n    }\r\n  };\r\n\r\n  const handleImport = async (cardsData) => {\r\n    try {\r\n      await bulkImportFlashcards(cardsData);\r\n      setMessage(`${SUCCESS_MESSAGES.IMPORT_SUCCESS}: ${cardsData.length} cards imported`);\r\n      clearMessage();\r\n    } catch (error) {\r\n      setError(error.message || 'Failed to import flashcards');\r\n    }\r\n  };\r\n\r\n  const handleGenerateQuestions = async (questionsData) => {\r\n    try {\r\n      await bulkImportFlashcards(questionsData);\r\n      setMessage(`‚ú® ${questionsData.length} AI-generated questions created successfully!`);\r\n      clearMessage();\r\n    } catch (error) {\r\n      setError(error.message || 'Failed to create generated questions');\r\n    }\r\n  };\r\n\r\n  const handleToggleCardActive = async (cardId, isActive) => {\r\n    try {\r\n      await updateFlashcard(cardId, { active: isActive });\r\n      setMessage(`Card ${isActive ? 'activated' : 'deactivated'} successfully`);\r\n      clearMessage();\r\n    } catch (error) {\r\n      setError(error.message || 'Failed to update card status');\r\n    }\r\n  };\r\n\r\n  // Create default flashcards for new users\r\n  const createDefaultFlashcards = async (currentUserId) => {\r\n    console.log('üîç createDefaultFlashcards called with:', {\r\n      currentUserId,\r\n      hasAddFlashcard: !!addFlashcard,\r\n      flashcardsLength: flashcards.length\r\n    });\r\n\r\n    if (!currentUserId || !addFlashcard) {\r\n      console.log('‚ùå Cannot create default cards: missing userId or addFlashcard function', {\r\n        currentUserId: !!currentUserId,\r\n        addFlashcard: !!addFlashcard\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Check if defaults have already been created for this user\r\n    const defaultsKey = `defaultCards_${currentUserId}`;\r\n    const hasDefaults = localStorage.getItem(defaultsKey);\r\n    \r\n    console.log('üîç Checking localStorage for defaults:', { defaultsKey, hasDefaults });\r\n    \r\n    if (hasDefaults) {\r\n      console.log('üìã Default cards already created for this user');\r\n      return;\r\n    }\r\n\r\n    // Check if user already has flashcards\r\n    console.log('üîç Checking flashcards length:', flashcards.length);\r\n    if (flashcards.length > 0) {\r\n      console.log('üìã User already has flashcards, skipping default creation');\r\n      localStorage.setItem(defaultsKey, 'true'); // Mark as having defaults to avoid future checks\r\n      return;\r\n    }\r\n\r\n    console.log('üìã Creating default flashcards for new user:', currentUserId);\r\n\r\n    const defaultCards = [\r\n      {\r\n        question: \"What is 2+2?\",\r\n        answer: \"4\",\r\n        category: \"Math\",\r\n        sub_category: \"Arithmetic\", \r\n        level: \"new\",\r\n        additional_info: \"Basic addition\"\r\n      },\r\n      {\r\n        question: \"Capital of France?\",\r\n        answer: \"Paris\",\r\n        category: \"Geography\",\r\n        sub_category: \"Europe\",\r\n        level: \"easy\", \r\n        additional_info: \"Located in Western Europe\"\r\n      }\r\n    ];\r\n\r\n    try {\r\n      let createdCount = 0;\r\n      for (const cardData of defaultCards) {\r\n        await addFlashcard(cardData);\r\n        createdCount++;\r\n      }\r\n      \r\n      // Mark defaults as created\r\n      localStorage.setItem(defaultsKey, 'true');\r\n      \r\n      console.log(`‚úÖ Successfully created ${createdCount} default flashcards`);\r\n      setMessage(`Welcome! We've added ${createdCount} sample cards to get you started.`);\r\n      clearMessage();\r\n      \r\n    } catch (error) {\r\n      console.error('‚ùå Error creating default flashcards:', error);\r\n      // Don't show error to user - this is a nice-to-have feature\r\n    }\r\n  };\r\n\r\n  // Handle edit card\r\n  const handleEditCard = (card) => {\r\n    setEditCardData(card);\r\n    setIsEditingCard(true);\r\n    setShowCreateCardForm(true);\r\n  };\r\n\r\n  // Window management functions\r\n  const handleMaximize = () => {\r\n    setIsMaximized(true);\r\n    setIsPopouted(false); // Don't use popout positioning for true fullscreen\r\n    setWindowPosition({ x: 0, y: 0 });\r\n    setWindowSize({ width: window.innerWidth, height: window.innerHeight });\r\n    // Removed direct DOM manipulation. Use React state and conditional rendering for fullscreen mode.\r\n  };\r\n\r\n  const handleRestore = () => {\r\n    // Reset all window states to default embedded view\r\n    setIsMaximized(false);\r\n    setIsPopouted(false);\r\n    setWindowPosition({ x: 0, y: 0 });\r\n    setWindowSize({ width: 1400, height: 900 });\r\n  };\r\n\r\n  const handlePopout = () => {\r\n    setIsPopouted(true);\r\n    setIsMaximized(false);\r\n    // Center the window and make it larger - use 90% of screen size or minimum size\r\n    const newWidth = Math.min(1800, Math.max(1400, window.innerWidth * 0.9));\r\n    const newHeight = Math.min(1200, Math.max(900, window.innerHeight * 0.9));\r\n    setWindowPosition({ \r\n      x: (window.innerWidth - newWidth) / 2, \r\n      y: Math.max(20, (window.innerHeight - newHeight) / 2)\r\n    });\r\n    setWindowSize({ width: newWidth, height: newHeight });\r\n  };\r\n\r\n  const handleClosePopout = () => {\r\n    setIsPopouted(false);\r\n    setIsMaximized(false);\r\n    setWindowPosition({ x: 0, y: 0 });\r\n    setWindowSize({ width: 1400, height: 900 });\r\n  };\r\n\r\n  // Notes popout handlers\r\n  const handleNotesPopout = () => {\r\n    setIsNotesPopouted(true);\r\n    setIsNotesCollapsed(false); // Ensure notes are expanded when popped out\r\n    // Center the notes window\r\n    const newWidth = 600;\r\n    const newHeight = 700;\r\n    setNotesWindowPosition({ \r\n      x: (window.innerWidth - newWidth) / 2, \r\n      y: Math.max(20, (window.innerHeight - newHeight) / 2)\r\n    });\r\n    setNotesWindowSize({ width: newWidth, height: newHeight });\r\n    // No direct DOM manipulation\r\n  };\r\n\r\n  const handleCloseNotesPopout = () => {\r\n    setIsNotesPopouted(false);\r\n    setNotesWindowPosition({ x: 100, y: 100 });\r\n    setNotesWindowSize({ width: 600, height: 700 });\r\n    // No direct DOM manipulation\r\n  };\r\n\r\n  // Explain functionality handlers\r\n  const handleOpenExplain = () => {\r\n    if (currentCard) {\r\n      const defaultPrompt = `Explain \"${currentCard.question?.replace(/<[^>]*>/g, '') || 'this question'}\" including concepts and why it is important to know`;\r\n      setExplainPrompt(defaultPrompt);\r\n    } else {\r\n      setExplainPrompt('Explain the current topic including concepts and why it is important to know');\r\n    }\r\n    setShowExplainModal(true);\r\n    setExplainError('');\r\n  };\r\n\r\n  const handleCloseExplain = () => {\r\n    setShowExplainModal(false);\r\n    setExplainPrompt('');\r\n    setExplainError('');\r\n  };\r\n\r\n  const handleGenerateExplanation = async () => {\r\n    if (!explainPrompt.trim()) {\r\n      setExplainError('Please enter a prompt for the explanation');\r\n      return;\r\n    }\r\n\r\n    const apiKey = apiKeys[selectedProvider];\r\n    if (!apiKey) {\r\n      setExplainError(`Please configure ${selectedProvider.toUpperCase()} API key in settings`);\r\n      return;\r\n    }\r\n\r\n    setIsGeneratingExplanation(true);\r\n    setExplainError('');\r\n\r\n    try {\r\n      const contextPrompt = `Context Information:\r\n${currentCard ? `Current Question: ${currentCard.question?.replace(/<[^>]*>/g, '') || ''}` : ''}\r\n${currentCard ? `Current Answer: ${currentCard.answer?.replace(/<[^>]*>/g, '') || ''}` : ''}\r\n${currentCard ? `Category: ${currentCard.category || 'General'}` : ''}\r\n${currentCard && currentCard.sub_category ? `Sub-category: ${currentCard.sub_category}` : ''}\r\n\r\nUser Request: ${explainPrompt}\r\n\r\nInstructions:\r\n1. Provide a comprehensive explanation based on the user's request\r\n2. Include key concepts and definitions\r\n3. Explain why this knowledge is important\r\n4. Use clear, educational language\r\n5. Format your response as HTML using these tags: <p>, <strong>, <em>, <ul>, <li>, <ol>\r\n6. Include examples when appropriate\r\n7. Start directly with HTML content - no markdown, no code blocks, no backticks\r\n\r\nEXAMPLE FORMAT:\r\n<p>This is a paragraph with <strong>important concepts</strong> and <em>emphasis</em>.</p>\r\n<ul>\r\n<li><strong>Concept 1:</strong> Explanation here</li>\r\n<li><strong>Concept 2:</strong> Another explanation</li>\r\n</ul>\r\n<p>Why this is important: explanation here.</p>\r\n\r\nIMPORTANT: Return ONLY HTML content, no markdown formatting, no code blocks.`;\r\n\r\n      const response = await callAI(contextPrompt, selectedProvider, apiKey);\r\n      \r\n      // Check if response is valid\r\n      if (!response || typeof response !== 'string') {\r\n        throw new Error('AI response was empty or invalid');\r\n      }\r\n      \r\n      // Clean up the response to ensure it's proper HTML\r\n      let cleanResponse = response.trim();\r\n      \r\n      console.log('Raw AI response:', response);\r\n      \r\n      // Remove any markdown code block formatting if present\r\n      cleanResponse = cleanResponse.replace(/```html\\s*/g, '').replace(/```\\s*$/g, '');\r\n      cleanResponse = cleanResponse.replace(/```\\s*/g, '').replace(/```\\s*$/g, '');\r\n      \r\n      console.log('After markdown cleanup:', cleanResponse);\r\n      \r\n      // Extract content from full HTML document structure if present\r\n      if (cleanResponse.includes('<!DOCTYPE') || cleanResponse.includes('<html>') || cleanResponse.includes('<body>')) {\r\n        console.log('Detected HTML document structure, cleaning...');\r\n        \r\n        // Try to extract body content first\r\n        const bodyMatch = cleanResponse.match(/<body[^>]*>([\\s\\S]*?)<\\/body>/i);\r\n        if (bodyMatch) {\r\n          cleanResponse = bodyMatch[1].trim();\r\n          console.log('Extracted from body tags:', cleanResponse);\r\n        } else {\r\n          // More aggressive fallback: remove all document structure\r\n          cleanResponse = cleanResponse\r\n            .replace(/<!DOCTYPE[^>]*>\\s*/gi, '')\r\n            .replace(/<html[^>]*>\\s*/gi, '')\r\n            .replace(/<\\/html>\\s*/gi, '')\r\n            .replace(/<head[\\s\\S]*?<\\/head>\\s*/gi, '')\r\n            .replace(/<body[^>]*>\\s*/gi, '')\r\n            .replace(/<\\/body>\\s*/gi, '')\r\n            .trim();\r\n          console.log('After aggressive cleanup:', cleanResponse);\r\n        }\r\n      } else {\r\n        console.log('No HTML document structure detected');\r\n      }\r\n      \r\n      // Ensure we have HTML tags, if not wrap in paragraph\r\n      if (!cleanResponse.includes('<') && cleanResponse.length > 0) {\r\n        cleanResponse = `<p>${cleanResponse}</p>`;\r\n      }\r\n      \r\n      // Convert HTML to plain text since notes use a textarea\r\n      const htmlToText = (html) => {\r\n        // Create a temporary div to parse HTML\r\n        const tempDiv = document.createElement('div');\r\n        tempDiv.innerHTML = html;\r\n        \r\n        // Convert common HTML elements to text equivalents\r\n        const processNode = (node) => {\r\n          let text = '';\r\n          for (let child of node.childNodes) {\r\n            if (child.nodeType === Node.TEXT_NODE) {\r\n              text += child.textContent;\r\n            } else if (child.nodeType === Node.ELEMENT_NODE) {\r\n              const tagName = child.tagName.toLowerCase();\r\n              switch (tagName) {\r\n                case 'h1':\r\n                case 'h2':\r\n                case 'h3':\r\n                case 'h4':\r\n                case 'h5':\r\n                case 'h6':\r\n                  text += '\\n\\n' + child.textContent.toUpperCase() + '\\n';\r\n                  break;\r\n                case 'p':\r\n                  text += '\\n\\n' + processNode(child) + '\\n';\r\n                  break;\r\n                case 'br':\r\n                  text += '\\n';\r\n                  break;\r\n                case 'li':\r\n                  text += '\\n‚Ä¢ ' + processNode(child);\r\n                  break;\r\n                case 'ul':\r\n                case 'ol':\r\n                  text += '\\n' + processNode(child) + '\\n';\r\n                  break;\r\n                case 'strong':\r\n                case 'b':\r\n                  text += '**' + child.textContent + '**';\r\n                  break;\r\n                case 'em':\r\n                case 'i':\r\n                  text += '*' + child.textContent + '*';\r\n                  break;\r\n                default:\r\n                  text += processNode(child);\r\n              }\r\n            }\r\n          }\r\n          return text;\r\n        };\r\n        \r\n        return processNode(tempDiv).trim();\r\n      };\r\n      \r\n      // Create a formatted explanation with a clear heading\r\n      const explanationTitle = `üí° AI EXPLANATION`;\r\n      const explanationText = htmlToText(cleanResponse);\r\n      const explanationContent = `${explanationTitle}\\n${'='.repeat(explanationTitle.length)}\\n\\n${explanationText}`;\r\n      \r\n      const currentNotes = notes.trim();\r\n      const newNotes = currentNotes ? `${currentNotes}\\n\\n${explanationContent}` : explanationContent;\r\n      \r\n      // Debug logging to see what we're getting\r\n      console.log('AI Response:', response);\r\n      console.log('Clean Response:', cleanResponse);\r\n      console.log('Final Notes Content:', newNotes);\r\n      \r\n      // Add explanation to question as dropdown if checkbox is checked\r\n      if (addExplanationToQuestion && currentCard) {\r\n        // Create a brief version of the explanation for the dropdown\r\n        const briefExplanationText = htmlToText(cleanResponse);\r\n        const maxLength = 300;\r\n        const truncatedExplanation = briefExplanationText.length > maxLength \r\n          ? briefExplanationText.substring(0, maxLength) + '...' \r\n          : briefExplanationText;\r\n        \r\n        // Simple lightbulb icon with hover tooltip at the beginning of question\r\n        // Limit explanation text for tooltip and escape properly\r\n        const tooltipText = explanationText.length > 500 \r\n          ? explanationText.substring(0, 500) + '...' \r\n          : explanationText;\r\n        const escapedTooltip = tooltipText\r\n          .replace(/\"/g, '&quot;')\r\n          .replace(/'/g, '&#39;')\r\n          .replace(/\\n/g, ' ')\r\n          .replace(/\\r/g, '');\r\n        \r\n        const explanationIcon = `<span class=\"ai-explanation-lightbulb\" title=\"${escapedTooltip}\">üí°</span> `;\r\n\r\n        // Prepend to question, not append\r\n        const updatedQuestion = `${explanationIcon}${currentCard.question || ''}`;\r\n\r\n        console.log('Current question:', currentCard.question);\r\n        console.log('Explanation icon HTML:', explanationIcon);\r\n        console.log('Updated question:', updatedQuestion);\r\n\r\n        // Update the card using the hook function - this will handle state updates automatically\r\n        if (currentCard.id) {\r\n          try {\r\n            await updateFlashcard(currentCard.id, { question: updatedQuestion });\r\n            console.log('Question updated with explanation dropdown');\r\n          } catch (error) {\r\n            console.error('Error updating card question:', error);\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Update notes directly - try to preserve HTML formatting\r\n      setNotes(newNotes);\r\n      \r\n      // Trigger a manual update to the editor if needed\r\n      setTimeout(() => {\r\n        localStorage.setItem('flashcard_session_notes', newNotes);\r\n      }, 100);\r\n      handleCloseExplain();\r\n    } catch (error) {\r\n      console.error('Explanation generation error:', error);\r\n      setExplainError('Failed to generate explanation: ' + error.message);\r\n    } finally {\r\n      setIsGeneratingExplanation(false);\r\n    }\r\n  };\r\n\r\n  // AI calling function for explanations\r\n  const callAI = async (prompt, provider, apiKey) => {\r\n    switch (provider) {\r\n      case 'openai':\r\n        return await callOpenAI(prompt, apiKey);\r\n      case 'anthropic':\r\n        return await callAnthropic(prompt, apiKey);\r\n      case 'gemini':\r\n        return await callGemini(prompt, apiKey);\r\n      default:\r\n        throw new Error('Unsupported AI provider');\r\n    }\r\n  };\r\n\r\n  const callOpenAI = async (prompt, apiKey) => {\r\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'Authorization': `Bearer ${apiKey}`\r\n      },\r\n      body: JSON.stringify({\r\n        model: 'gpt-3.5-turbo',\r\n        messages: [\r\n          { role: 'system', content: 'You are an educational expert who provides clear, comprehensive explanations of concepts. Always format your responses with proper HTML for readability.' },\r\n          { role: 'user', content: prompt }\r\n        ],\r\n        temperature: 0.7,\r\n        max_tokens: 1000\r\n      })\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const error = await response.json();\r\n      throw new Error(`OpenAI API error: ${error.error?.message || 'Unknown error'}`);\r\n    }\r\n\r\n    const data = await response.json();\r\n    const content = data.choices[0]?.message?.content;\r\n    if (!content) {\r\n      throw new Error('No content received from OpenAI API');\r\n    }\r\n    return content;\r\n  };\r\n\r\n  const callAnthropic = async (prompt, apiKey) => {\r\n    const response = await fetch('https://api.anthropic.com/v1/messages', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'x-api-key': apiKey,\r\n        'anthropic-version': '2023-06-01'\r\n      },\r\n      body: JSON.stringify({\r\n        model: 'claude-3-sonnet-20240229',\r\n        max_tokens: 1000,\r\n        temperature: 0.7,\r\n        messages: [\r\n          { role: 'user', content: prompt }\r\n        ]\r\n      })\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorData = await response.json();\r\n      throw new Error(`Anthropic API error: ${errorData.error?.message || 'Unknown error'}`);\r\n    }\r\n\r\n    const data = await response.json();\r\n    const content = data.content[0]?.text;\r\n    if (!content) {\r\n      throw new Error('No content received from Anthropic API');\r\n    }\r\n    return content;\r\n  };\r\n\r\n  const callGemini = async (prompt, apiKey) => {\r\n    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json'\r\n      },\r\n      body: JSON.stringify({\r\n        contents: [\r\n          {\r\n            parts: [{ text: prompt }]\r\n          }\r\n        ],\r\n        generationConfig: {\r\n          temperature: 0.7,\r\n          maxOutputTokens: 1000\r\n        }\r\n      })\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const error = await response.json();\r\n      throw new Error(`Gemini API error: ${error.error?.message || 'Unknown error'}`);\r\n    }\r\n\r\n    const data = await response.json();\r\n    const content = data.candidates[0]?.content?.parts[0]?.text;\r\n    if (!content) {\r\n      throw new Error('No content received from Gemini API');\r\n    }\r\n    return content;\r\n  };\r\n\r\n  const handleRestorePosition = () => {\r\n    // This function should restore to default embedded view, same as handleRestore\r\n    handleRestore();\r\n  };\r\n\r\n  const handleMouseDown = (e) => {\r\n    if (isMaximized || isResizing) return;\r\n    setIsDragging(true);\r\n    setDragOffset({\r\n      x: e.clientX - windowPosition.x,\r\n      y: e.clientY - windowPosition.y\r\n    });\r\n  };\r\n\r\n  const handleResizeStart = (e, direction) => {\r\n    e.stopPropagation();\r\n    setIsResizing(true);\r\n    setResizeDirection(direction);\r\n    setResizeStart({\r\n      x: e.clientX,\r\n      y: e.clientY,\r\n      width: windowSize.width,\r\n      height: windowSize.height\r\n    });\r\n  };\r\n\r\n  const handleMouseMove = useCallback((e) => {\r\n    if (isDragging && !isMaximized && isPopouted) {\r\n      setWindowPosition({\r\n        x: e.clientX - dragOffset.x,\r\n        y: e.clientY - dragOffset.y\r\n      });\r\n    } else if (isResizing) {\r\n      const deltaX = e.clientX - resizeStart.x;\r\n      const deltaY = e.clientY - resizeStart.y;\r\n      let newWidth = resizeStart.width;\r\n      let newHeight = resizeStart.height;\r\n      let newX = windowPosition.x;\r\n      let newY = windowPosition.y;\r\n\r\n      if (resizeDirection.includes('e')) newWidth = Math.max(400, resizeStart.width + deltaX);\r\n      if (resizeDirection.includes('w')) {\r\n        newWidth = Math.max(400, resizeStart.width - deltaX);\r\n        newX = windowPosition.x + (resizeStart.width - newWidth);\r\n      }\r\n      if (resizeDirection.includes('s')) newHeight = Math.max(300, resizeStart.height + deltaY);\r\n      if (resizeDirection.includes('n')) {\r\n        newHeight = Math.max(300, resizeStart.height - deltaY);\r\n        newY = windowPosition.y + (resizeStart.height - newHeight);\r\n      }\r\n\r\n      setWindowSize({ width: newWidth, height: newHeight });\r\n      if (resizeDirection.includes('w') || resizeDirection.includes('n')) {\r\n        setWindowPosition({ x: newX, y: newY });\r\n      }\r\n    }\r\n  }, [isDragging, dragOffset, isMaximized, isPopouted, isResizing, resizeDirection, resizeStart, windowPosition]);\r\n\r\n  const handleMouseUp = useCallback(() => {\r\n    setIsDragging(false);\r\n    setIsResizing(false);\r\n    setResizeDirection('');\r\n  }, []);\r\n\r\n  // Notes window drag handlers\r\n  const handleNotesMouseDown = (e) => {\r\n    if (isNotesResizing) return;\r\n    setIsNotesDragging(true);\r\n    setNotesDragOffset({\r\n      x: e.clientX - notesWindowPosition.x,\r\n      y: e.clientY - notesWindowPosition.y\r\n    });\r\n  };\r\n\r\n  const handleNotesResizeStart = (e, direction) => {\r\n    e.stopPropagation();\r\n    setIsNotesResizing(true);\r\n    setNotesResizeDirection(direction);\r\n    setNotesResizeStart({\r\n      x: e.clientX,\r\n      y: e.clientY,\r\n      width: notesWindowSize.width,\r\n      height: notesWindowSize.height\r\n    });\r\n  };\r\n\r\n  const handleNotesMouseMove = useCallback((e) => {\r\n    if (isNotesDragging && isNotesPopouted) {\r\n      const newX = e.clientX - notesDragOffset.x;\r\n      const newY = e.clientY - notesDragOffset.y;\r\n      \r\n      // Keep window within viewport\r\n      const maxX = window.innerWidth - notesWindowSize.width;\r\n      const maxY = window.innerHeight - notesWindowSize.height;\r\n      \r\n      setNotesWindowPosition({\r\n        x: Math.max(0, Math.min(newX, maxX)),\r\n        y: Math.max(0, Math.min(newY, maxY))\r\n      });\r\n    }\r\n    \r\n    if (isNotesResizing) {\r\n      const deltaX = e.clientX - notesResizeStart.x;\r\n      const deltaY = e.clientY - notesResizeStart.y;\r\n      let newWidth = notesWindowSize.width;\r\n      let newHeight = notesWindowSize.height;\r\n      let newX = notesWindowPosition.x;\r\n      let newY = notesWindowPosition.y;\r\n\r\n      if (notesResizeDirection.includes('e')) newWidth = notesResizeStart.width + deltaX;\r\n      if (notesResizeDirection.includes('w')) {\r\n        newWidth = notesResizeStart.width - deltaX;\r\n        newX = notesWindowPosition.x + deltaX;\r\n      }\r\n      if (notesResizeDirection.includes('s')) newHeight = notesResizeStart.height + deltaY;\r\n      if (notesResizeDirection.includes('n')) {\r\n        newHeight = notesResizeStart.height - deltaY;\r\n        newY = notesWindowPosition.y + deltaY;\r\n      }\r\n\r\n      // Minimum size constraints\r\n      newWidth = Math.max(400, Math.min(newWidth, window.innerWidth - 50));\r\n      newHeight = Math.max(300, Math.min(newHeight, window.innerHeight - 50));\r\n\r\n      setNotesWindowSize({ width: newWidth, height: newHeight });\r\n      if (notesResizeDirection.includes('w') || notesResizeDirection.includes('n')) {\r\n        setNotesWindowPosition({ x: newX, y: newY });\r\n      }\r\n    }\r\n  }, [isNotesDragging, notesDragOffset, isNotesPopouted, isNotesResizing, notesResizeDirection, notesResizeStart, notesWindowPosition, notesWindowSize]);\r\n\r\n  const handleNotesMouseUp = useCallback(() => {\r\n    setIsNotesDragging(false);\r\n    setIsNotesResizing(false);\r\n    setNotesResizeDirection('');\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (isDragging || isResizing) {\r\n      document.addEventListener('mousemove', handleMouseMove);\r\n      document.addEventListener('mouseup', handleMouseUp);\r\n      return () => {\r\n        document.removeEventListener('mousemove', handleMouseMove);\r\n        document.removeEventListener('mouseup', handleMouseUp);\r\n      };\r\n    }\r\n  }, [isDragging, isResizing, handleMouseMove, handleMouseUp]);\r\n\r\n  useEffect(() => {\r\n    if (isNotesDragging || isNotesResizing) {\r\n      document.addEventListener('mousemove', handleNotesMouseMove);\r\n      document.addEventListener('mouseup', handleNotesMouseUp);\r\n      return () => {\r\n        document.removeEventListener('mousemove', handleNotesMouseMove);\r\n        document.removeEventListener('mouseup', handleNotesMouseUp);\r\n      };\r\n    }\r\n  }, [isNotesDragging, isNotesResizing, handleNotesMouseMove, handleNotesMouseUp]);\r\n\r\n  // Handle ESC key to exit fullscreen\r\n  useEffect(() => {\r\n    const handleKeyDown = (e) => {\r\n      if (e.key === 'Escape' && isMaximized) {\r\n        handleRestore();\r\n      }\r\n    };\r\n\r\n    if (isMaximized) {\r\n      document.addEventListener('keydown', handleKeyDown);\r\n      return () => {\r\n        document.removeEventListener('keydown', handleKeyDown);\r\n      };\r\n    }\r\n  }, [isMaximized]);\r\n\r\n  // Clear messages after delay\r\n  const clearMessage = useCallback(() => {\r\n    setTimeout(() => {\r\n      setMessage('');\r\n    }, 3000);\r\n  }, []);\r\n\r\n  const clearError = () => {\r\n    setError('');\r\n    clearAuthError();\r\n    clearFlashcardsError();\r\n    clearSettingsError();\r\n  };\r\n\r\n  // Handle API key updates\r\n  const handleApiKeysUpdate = (newApiKeys, newSelectedProvider) => {\r\n    setApiKeys(newApiKeys);\r\n    setSelectedProvider(newSelectedProvider);\r\n    \r\n    // Save to localStorage\r\n    Object.entries(newApiKeys).forEach(([provider, key]) => {\r\n      if (key) {\r\n        localStorage.setItem(`${provider}_api_key`, key);\r\n      } else {\r\n        localStorage.removeItem(`${provider}_api_key`);\r\n      }\r\n    });\r\n    \r\n    localStorage.setItem('selected_ai_provider', newSelectedProvider);\r\n  };\r\n\r\n  // Keyboard shortcuts\r\n  useEffect(() => {\r\n    const handleKeyDown = (event) => {\r\n      // Don't trigger shortcuts if user is typing in an input\r\n      if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.contentEditable === 'true') {\r\n        return;\r\n      }\r\n\r\n      switch (event.key) {\r\n        case ' ':\r\n        case 'Enter':\r\n          event.preventDefault();\r\n          // Toggle answer visibility\r\n          console.log('Toggle answer:', showAnswer, '->', !showAnswer);\r\n          setShowAnswer(prev => !prev);\r\n          break;\r\n        case 'ArrowLeft':\r\n        case 'p':\r\n          event.preventDefault();\r\n          prevCard();\r\n          break;\r\n        case 'ArrowRight':\r\n        case 'n':\r\n          event.preventDefault();\r\n          nextCard();\r\n          break;\r\n        case '1':\r\n          // Only allow rating when answer is shown\r\n          if (showAnswer && getCurrentCard()) {\r\n            event.preventDefault();\r\n            handleReviewCard('again');\r\n          }\r\n          break;\r\n        case '2':\r\n          // Only allow rating when answer is shown\r\n          if (showAnswer && getCurrentCard()) {\r\n            event.preventDefault();\r\n            handleReviewCard('hard');\r\n          }\r\n          break;\r\n        case '3':\r\n          // Only allow rating when answer is shown\r\n          if (showAnswer && getCurrentCard()) {\r\n            event.preventDefault();\r\n            handleReviewCard('good');\r\n          }\r\n          break;\r\n        case '4':\r\n          // Only allow rating when answer is shown\r\n          if (showAnswer && getCurrentCard()) {\r\n            event.preventDefault();\r\n            handleReviewCard('easy');\r\n          }\r\n          break;\r\n        case 'c':\r\n          if (event.ctrlKey || event.metaKey) return; // Don't interfere with copy\r\n          event.preventDefault();\r\n          setShowCreateCardForm(true);\r\n          break;\r\n        case 's':\r\n          if (event.ctrlKey || event.metaKey) return; // Don't interfere with save\r\n          event.preventDefault();\r\n          setShowSettingsModal(true);\r\n          break;\r\n        case 'e':\r\n          // Edit current card if available\r\n          if (getCurrentCard()) {\r\n            event.preventDefault();\r\n            handleEditCard(getCurrentCard());\r\n          }\r\n          break;\r\n        case 'g':\r\n          // Generate questions if available\r\n          event.preventDefault();\r\n          setShowGenerateModal(true);\r\n          break;\r\n        case 'i':\r\n          // Import/Export modal\r\n          event.preventDefault();\r\n          setShowImportExportModal(true);\r\n          break;\r\n        case 'm':\r\n          event.preventDefault();\r\n          setShowManageCardsModal(true);\r\n          break;\r\n        case 'Escape':\r\n          event.preventDefault();\r\n          setShowCreateCardForm(false);\r\n          setShowSettingsModal(false);\r\n          setShowImportExportModal(false);\r\n          setShowCalendarModal(false);\r\n          setShowManageCardsModal(false);\r\n          setShowGenerateModal(false);\r\n          setIsEditingCard(false);\r\n          setEditCardData(null);\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    };\r\n\r\n    document.addEventListener('keydown', handleKeyDown);\r\n    return () => document.removeEventListener('keydown', handleKeyDown);\r\n  }, [showAnswer, nextCard, prevCard, setShowAnswer, handleReviewCard, getCurrentCard, handleEditCard]);\r\n\r\n  // Computed values now declared earlier in the component\r\n\r\n  // Save notes to localStorage when changed\r\n  useEffect(() => {\r\n    localStorage.setItem('flashcard_session_notes', notes);\r\n  }, [notes]);\r\n\r\n  // Handle notes text change\r\n  const handleNotesChange = (value) => {\r\n    setNotes(value);\r\n  };\r\n\r\n  // Clear notes\r\n  const handleClearNotes = () => {\r\n    setNotes('');\r\n  };\r\n  \r\n  // Get due cards for easy access\r\n  const pastDueCards = getPastDueCards();\r\n  const cardsDueToday = getCardsDueToday();\r\n  const allDueCards = getAllDueCards();\r\n  const filteredDueCards = getFilteredDueCards();\r\n  const cardsReviewedToday = getCardsReviewedToday();\r\n  \r\n  // Get starred cards\r\n  const starredCards = useMemo(() => {\r\n    if (!flashcards || !Array.isArray(flashcards)) return [];\r\n    return flashcards.filter(card => card.active !== false && card.starred === true);\r\n  }, [flashcards]);\r\n\r\n  // Get starred cards count based on current view mode\r\n  const starredCardsCount = useMemo(() => {\r\n    if (!flashcards || !Array.isArray(flashcards)) return 0;\r\n    \r\n    if (showDueTodayOnly) {\r\n      // Show only starred cards that are also due\r\n      const starredDueCards = filteredDueCards.filter(card => card.starred === true);\r\n      return starredDueCards.length;\r\n    } else {\r\n      // Show all starred cards\r\n      return starredCards.length;\r\n    }\r\n  }, [flashcards, showDueTodayOnly, filteredDueCards, starredCards]);\r\n\r\n  // Load streak from localStorage on mount\r\n  useEffect(() => {\r\n    if (userId) {\r\n      const savedStreak = localStorage.getItem(`streak_${userId}`) || '0';\r\n      setStreakDays(parseInt(savedStreak, 10));\r\n    }\r\n  }, [userId]);\r\n\r\n  // Initialize daily due cards count\r\n  useEffect(() => {\r\n    if (userId && allDueCards.length > 0 && categoryStats && subCategoryStats) {\r\n      const today = new Date().toDateString();\r\n      const storedDate = localStorage.getItem(`flashcard_due_date_${userId}`);\r\n      const storedCount = localStorage.getItem(`flashcard_initial_due_${userId}`);\r\n      const storedCompleted = localStorage.getItem(`flashcard_completed_today_${userId}`);\r\n      const storedCategoryStats = localStorage.getItem(`flashcard_initial_category_stats_${userId}`);\r\n      const storedCategoryCompleted = localStorage.getItem(`flashcard_category_completed_${userId}`);\r\n      const storedSubCategoryStats = localStorage.getItem(`flashcard_initial_subcategory_stats_${userId}`);\r\n      const storedSubCategoryCompleted = localStorage.getItem(`flashcard_subcategory_completed_${userId}`);\r\n      \r\n      // If it's a new day or first time, reset counts\r\n      if (storedDate !== today) {\r\n        const newInitialCount = allDueCards.length;\r\n        const newCategoryStats = categoryStats;\r\n        const newSubCategoryStats = getAllSubCategoryStats();\r\n        \r\n        console.log('üîÑ COUNTING-INIT: Setting initial stats for new day');\r\n        console.log('üîÑ Initial category stats:', newCategoryStats);\r\n        console.log('üîÑ Initial subcategory stats keys:', Object.keys(newSubCategoryStats));\r\n        console.log('üîÑ Total due cards:', newInitialCount);\r\n        \r\n        setInitialDueCardsCount(newInitialCount);\r\n        setCardsCompletedToday(0);\r\n        setInitialCategoryStats(newCategoryStats);\r\n        setCategoryCompletedCounts({});\r\n        setInitialSubCategoryStats(newSubCategoryStats);\r\n        setSubCategoryCompletedCounts({});\r\n        localStorage.setItem(`flashcard_due_date_${userId}`, today);\r\n        localStorage.setItem(`flashcard_initial_due_${userId}`, newInitialCount.toString());\r\n        localStorage.setItem(`flashcard_completed_today_${userId}`, '0');\r\n        localStorage.setItem(`flashcard_initial_category_stats_${userId}`, JSON.stringify(newCategoryStats));\r\n        localStorage.setItem(`flashcard_category_completed_${userId}`, JSON.stringify({}));\r\n        localStorage.setItem(`flashcard_initial_subcategory_stats_${userId}`, JSON.stringify(newSubCategoryStats));\r\n        localStorage.setItem(`flashcard_subcategory_completed_${userId}`, JSON.stringify({}));\r\n      } else {\r\n        // Restore counts from localStorage\r\n        setInitialDueCardsCount(parseInt(storedCount) || allDueCards.length);\r\n        setCardsCompletedToday(parseInt(storedCompleted) || 0);\r\n        setInitialCategoryStats(storedCategoryStats ? JSON.parse(storedCategoryStats) : categoryStats);\r\n        setCategoryCompletedCounts(storedCategoryCompleted ? JSON.parse(storedCategoryCompleted) : {});\r\n        setInitialSubCategoryStats(storedSubCategoryStats ? JSON.parse(storedSubCategoryStats) : getAllSubCategoryStats());\r\n        setSubCategoryCompletedCounts(storedSubCategoryCompleted ? JSON.parse(storedSubCategoryCompleted) : {});\r\n      }\r\n    }\r\n  }, [userId, allDueCards.length, categoryStats, getAllSubCategoryStats]);\r\n\r\n  // Fix completion count inconsistencies - DISABLED to prevent infinite loop\r\n  useEffect(() => {\r\n    // Disabled to prevent infinite loop - use window.debugCounting.reset() instead\r\n    return;\r\n  }, []);\r\n\r\n  // Check and update streak when all cards are completed\r\n  useEffect(() => {\r\n    if (!userId || !flashcards.length) return;\r\n\r\n    const today = new Date();\r\n    today.setHours(0, 0, 0, 0);\r\n    const todayString = today.toDateString();\r\n    \r\n    // Check if all cards have been completed today\r\n    const allCardsCompleted = allDueCards.length === 0 && flashcards.length > 0;\r\n    \r\n    if (allCardsCompleted) {\r\n      const lastCompletionDate = localStorage.getItem(`lastCompletion_${userId}`);\r\n      const lastStreakUpdate = localStorage.getItem(`lastStreakUpdate_${userId}`);\r\n      \r\n      // Only update streak once per day\r\n      if (lastStreakUpdate !== todayString) {\r\n        let newStreak = streakDays;\r\n        \r\n        if (lastCompletionDate) {\r\n          const lastDate = new Date(lastCompletionDate);\r\n          const yesterday = new Date(today);\r\n          yesterday.setDate(yesterday.getDate() - 1);\r\n          \r\n          // If last completion was yesterday, increment streak\r\n          if (lastDate.toDateString() === yesterday.toDateString()) {\r\n            newStreak = streakDays + 1;\r\n          } else if (lastDate.toDateString() === todayString) {\r\n            // Already completed today, keep current streak\r\n            newStreak = streakDays;\r\n          } else {\r\n            // Gap in completions, reset streak to 1\r\n            newStreak = 1;\r\n          }\r\n        } else {\r\n          // First completion ever\r\n          newStreak = 1;\r\n        }\r\n        \r\n        setStreakDays(newStreak);\r\n        localStorage.setItem(`streak_${userId}`, newStreak.toString());\r\n        localStorage.setItem(`lastCompletion_${userId}`, todayString);\r\n        localStorage.setItem(`lastStreakUpdate_${userId}`, todayString);\r\n      }\r\n    }\r\n  }, [userId, allDueCards.length, flashcards.length, streakDays]);\r\n\r\n  // Auto-switch to \"All\" if selected category has no due cards (using stable counting)\r\n  useEffect(() => {\r\n    if (!showDueTodayOnly || selectedCategory === 'All') return;\r\n\r\n    // TEMPORARILY DISABLE CATEGORY AUTO-SWITCH TO DEBUG SWITCHING\r\n    const categoryAutoSwitchDisabled = true;\r\n\r\n    // Don't auto-switch if user is manually selecting categories\r\n    if (isManualCategorySelection) {\r\n      console.log(`üìÇ Skipping auto-switch for \"${selectedCategory}\" - manual category selection in progress`);\r\n      return;\r\n    }\r\n\r\n    // Don't auto-switch if user manually selected a category in the last 10 seconds\r\n    const timeSinceManualChange = Date.now() - lastManualCategoryChange;\r\n    if (timeSinceManualChange < 10000) {\r\n      console.log(`üìÇ Skipping auto-switch for \"${selectedCategory}\" - manual selection too recent (${timeSinceManualChange}ms ago)`);\r\n      return;\r\n    }\r\n\r\n    // Use real-time count for auto-switch logic\r\n    const now = new Date();\r\n    const endOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);\r\n    const categoryDueCards = flashcards.filter(card => {\r\n      if (card.active === false) return false;\r\n      if ((card.category || 'Uncategorized') !== selectedCategory) return false;\r\n      let dueDate = card.dueDate || new Date(0);\r\n      if (dueDate && typeof dueDate.toDate === 'function') {\r\n        dueDate = dueDate.toDate();\r\n      }\r\n      return dueDate < endOfToday;\r\n    });\r\n\r\n    if (categoryDueCards.length === 0) {\r\n      if (categoryAutoSwitchDisabled) {\r\n        console.log(`üö´ CATEGORY AUTO-SWITCH: Would switch \"${selectedCategory}\" to \"All\" but auto-switch is disabled`);\r\n      } else {\r\n        console.log(`üìÇ Category \"${selectedCategory}\" has no due cards remaining, switching to \"All\"`);\r\n        setSelectedCategory('All');\r\n      }\r\n    }\r\n  }, [selectedCategory, showDueTodayOnly, setSelectedCategory, flashcards, lastManualCategoryChange, isManualCategorySelection]);\r\n  \r\n  // Log due cards info on initial load (useful for debugging)\r\n  useEffect(() => {\r\n    console.log('üìä Due Cards Summary:', {\r\n      pastDue: pastDueCards.length,\r\n      dueToday: cardsDueToday.length,\r\n      totalDue: allDueCards.length,\r\n      filteredDue: filteredDueCards.length,\r\n      filteredFlashcards: filteredFlashcards.length,\r\n      showDueTodayOnly: showDueTodayOnly,\r\n      selectedCategory: selectedCategory,\r\n      selectedSubCategory: selectedSubCategory,\r\n      pastDueCards: pastDueCards.map(card => ({ \r\n        question: card.question?.substring(0, 50), \r\n        dueDate: card.dueDate \r\n      })),\r\n      cardsDueToday: cardsDueToday.map(card => ({ \r\n        question: card.question?.substring(0, 50), \r\n        dueDate: card.dueDate \r\n      }))\r\n    });\r\n    \r\n    // Run detailed debug when due cards are expected but not showing\r\n    if (showDueTodayOnly && filteredFlashcards.length === 0 && allDueCards.length > 0) {\r\n      console.log('‚ö†Ô∏è WARNING: Due cards exist but none are showing!');\r\n      debugDueCards(flashcards, selectedCategory, selectedSubCategory);\r\n    }\r\n  }, [pastDueCards.length, cardsDueToday.length, allDueCards.length, filteredDueCards.length, filteredFlashcards.length, showDueTodayOnly, selectedCategory, selectedSubCategory, flashcards]);\r\n\r\n  // CATEGORY SYNC DEBUG: Track category changes to identify timing issues\r\n  useEffect(() => {\r\n    if (flashcards.length > 0) {\r\n      const awsCards = flashcards.filter(card =>\r\n        (card.category || '').toLowerCase().includes('aws')\r\n      );\r\n\r\n      console.log('üîç CATEGORY SYNC DEBUG:', {\r\n        flashcardsLength: flashcards.length,\r\n        categoriesLength: categories.length,\r\n        categories: categories,\r\n        awsCardsFound: awsCards.length,\r\n        awsInCategories: categories.includes('AWS'),\r\n        awsInCategoriesLower: categories.includes('aws'),\r\n        showDueTodayOnly,\r\n        showStarredOnly,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n\r\n      // Specific AWS debugging\r\n      if (awsCards.length > 0) {\r\n        console.log('üîç AWS CARDS DETAIL:', awsCards.map(card => ({\r\n          id: card.id,\r\n          category: card.category,\r\n          active: card.active,\r\n          question: card.question?.substring(0, 50)\r\n        })));\r\n      }\r\n    }\r\n  }, [flashcards, categories, showDueTodayOnly, showStarredOnly]);\r\n\r\n  // SUBCATEGORY SYNC DEBUG: Track subcategory filtering issues\r\n  useEffect(() => {\r\n    if (flashcards.length > 0) {\r\n      console.log('üîç SUBCATEGORY SYNC DEBUG:', {\r\n        selectedCategory,\r\n        selectedSubCategory,\r\n        subCategoriesLength: subCategories.length,\r\n        subCategories: subCategories,\r\n        showDueTodayOnly,\r\n        showStarredOnly,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n\r\n      // Show cards in selected category and their subcategories\r\n      if (selectedCategory !== 'All') {\r\n        const categoryCards = flashcards.filter(card =>\r\n          card.active !== false && card.category === selectedCategory\r\n        );\r\n\r\n        const categorySubCategories = [...new Set(\r\n          categoryCards.map(card => card.sub_category || 'Uncategorized')\r\n        )];\r\n\r\n        console.log('üîç CATEGORY CARDS DETAIL:', {\r\n          selectedCategory,\r\n          cardsInCategory: categoryCards.length,\r\n          actualSubCategories: categorySubCategories,\r\n          filteredSubCategories: subCategories,\r\n          mismatch: categorySubCategories.length !== subCategories.length\r\n        });\r\n      }\r\n    }\r\n  }, [flashcards, selectedCategory, selectedSubCategory, subCategories, showDueTodayOnly, showStarredOnly]);\r\n\r\n  // Auto-navigation to next category with due cards\r\n  useEffect(() => {\r\n\r\n    // Re-enable auto-navigation now that filtering is fixed\r\n    const categoryAutoNavigationDisabled = false;\r\n\r\n    // Enhanced auto-advance logic: Only auto-navigate when:\r\n    // 1. We're showing due cards only (showDueTodayOnly mode is active)\r\n    // 2. We have a specific category selected (not \"All\")\r\n    // 3. We have a specific subcategory selected (not \"All\") - current subcategory is finished\r\n    // 4. There are no filtered cards left in the current subcategory\r\n    // 5. There are still due cards somewhere in the system\r\n    // 6. User hasn't manually selected a category/subcategory recently\r\n    const timeSinceManualCategoryChange = Date.now() - lastManualCategoryChange;\r\n    const timeSinceManualSubCategoryChange = Date.now() - lastManualSubCategoryChange;\r\n    const timeSinceLastCardCompletion = Date.now() - lastCardCompletion;\r\n    \r\n    // Calculate due cards specifically in the current subcategory from ALL flashcards\r\n    const now = new Date();\r\n    const endOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);\r\n    \r\n    const currentSubcategoryDueCards = flashcards.filter(card => {\r\n      // Must be active\r\n      if (card.active === false) return false;\r\n      \r\n      // Must match current category\r\n      if (selectedCategory !== 'All' && card.category !== selectedCategory) return false;\r\n      \r\n      // Must match current subcategory  \r\n      if (selectedSubCategory !== 'All') {\r\n        const cardSubCategory = card.sub_category && card.sub_category.trim() ? card.sub_category : 'Uncategorized';\r\n        if (cardSubCategory !== selectedSubCategory) return false;\r\n      }\r\n      \r\n      // Must be due (if in due cards mode)\r\n      if (showDueTodayOnly) {\r\n        let dueDate = card.dueDate || new Date(0);\r\n        if (dueDate && typeof dueDate.toDate === 'function') {\r\n          dueDate = dueDate.toDate();\r\n        }\r\n        return dueDate < endOfToday;\r\n      }\r\n      \r\n      return true;\r\n    });\r\n\r\n    // Trigger auto-advance when current subcategory has no more due cards\r\n    // IMPORTANT: Both filteredFlashcards and currentSubcategoryDueCards must be empty\r\n    // This prevents auto-advance when there are still cards available in the current view\r\n    const shouldTriggerAutoAdvance = (\r\n      showDueTodayOnly && \r\n      selectedCategory !== 'All' && \r\n      selectedSubCategory !== 'All' &&\r\n      currentSubcategoryDueCards.length === 0 && // No due cards in current subcategory\r\n      filteredFlashcards.length === 0 && // No cards currently displayed \r\n      allDueCards.length > 0 && // But due cards exist elsewhere\r\n      !isManualCategorySelection && \r\n      timeSinceManualCategoryChange > 5000 && // 5s delay for category changes\r\n      timeSinceManualSubCategoryChange > 3000 && // 3s delay for subcategory changes\r\n      timeSinceLastCardCompletion > 500 && // 0.5s delay after card completion to avoid immediate trigger\r\n      !categoryAutoNavigationDisabled\r\n    );\r\n\r\n    // Add debugging to understand the state\r\n    if (selectedSubCategory !== 'All' && selectedCategory !== 'All') {\r\n      console.log('üîç SUBCATEGORY DEBUG:', {\r\n        selectedCategory,\r\n        selectedSubCategory,\r\n        currentSubcategoryDueCards: currentSubcategoryDueCards.length,\r\n        filteredFlashcardsLength: filteredFlashcards.length,\r\n        allDueCardsLength: allDueCards.length,\r\n        shouldTriggerAutoAdvance,\r\n        showDueTodayOnly,\r\n        timeSinceManualCategoryChange,\r\n        timeSinceManualSubCategoryChange,\r\n        timeSinceLastCardCompletion\r\n      });\r\n    }\r\n\r\n    if (shouldTriggerAutoAdvance) {\r\n      console.log('üîÑ Subcategory auto-advance triggered:', {\r\n        selectedCategory,\r\n        selectedSubCategory,\r\n        currentSubcategoryDueCards: currentSubcategoryDueCards.length,\r\n        filteredFlashcardsLength: filteredFlashcards.length,\r\n        allDueCardsLength: allDueCards.length\r\n      });\r\n      \r\n      // Step 1: Check if there are other subcategories with due cards in the current category\r\n      // This function returns the subcategory with the LEAST TOTAL CARDS (not just due cards)\r\n      const nextSubCategory = getNextSubCategoryWithLeastCards(selectedCategory, selectedSubCategory);\r\n      const hasSubcategoriesWithDueCards = nextSubCategory !== null;\r\n\r\n      console.log('üîÑ Subcategory auto-advance analysis:', {\r\n        currentCategory: selectedCategory,\r\n        currentSubCategory: selectedSubCategory,\r\n        nextSubCategoryWithLeastCards: nextSubCategory,\r\n        hasOtherSubcategoriesWithDueCards: hasSubcategoriesWithDueCards\r\n      });\r\n\r\n      // Step 2: If there are other subcategories with due cards, switch to the one with least total cards\r\n      if (hasSubcategoriesWithDueCards) {\r\n        console.log(`üîÑ SUBCATEGORY AUTO-ADVANCE: Switching from \"${selectedSubCategory}\" to \"${nextSubCategory}\" within category \"${selectedCategory}\" (subcategory with least total cards)`);\r\n\r\n        // Get total card counts for user feedback\r\n        const subCategoryStats = getSubCategoryStats(selectedCategory);\r\n        const nextSubCategoryTotalCards = subCategoryStats[nextSubCategory]?.total || 0;\r\n        const nextSubCategoryDueCards = subCategoryStats[nextSubCategory]?.due || 0;\r\n\r\n        setTimeout(() => {\r\n          setSelectedSubCategory(nextSubCategory);\r\n          setMessage(`Completed \"${selectedSubCategory}\"! Switched to \"${nextSubCategory}\" (${nextSubCategoryTotalCards} cards, ${nextSubCategoryDueCards} due)`);\r\n\r\n          // Clear message after 4 seconds to give user time to read the details\r\n          setTimeout(() => setMessage(''), 4000);\r\n        }, 100); // Reduced delay since we want immediate feedback\r\n\r\n        return; // Don't switch categories - stay within current category\r\n      }\r\n\r\n      // Step 3: Only switch categories if NO subcategories in current category have due cards left\r\n      if (!hasSubcategoriesWithDueCards) {\r\n        console.log(`üîÑ CATEGORY AUTO-ADVANCE: No more subcategories with due cards in \"${selectedCategory}\", looking for next category`);\r\n        \r\n        const nextCategory = getNextCategoryWithDueCards(selectedCategory);\r\n        \r\n        if (nextCategory) {\r\n          console.log(`üîÑ CATEGORY AUTO-ADVANCE: Switching from category \"${selectedCategory}\" to \"${nextCategory}\" (all subcategories in ${selectedCategory} completed)`);\r\n          setSelectedCategory(nextCategory);\r\n          setSelectedSubCategory('All'); // Reset subcategory when switching categories\r\n          // Ensure we stay in due cards mode\r\n          setShowDueTodayOnly(true);\r\n          setMessage(`Category \"${selectedCategory}\" completed! Switched to \"${nextCategory}\" category`);\r\n          \r\n          // Clear message after 4 seconds\r\n          setTimeout(() => setMessage(''), 4000);\r\n        } else {\r\n          console.log('üéâ STUDY SESSION COMPLETE: All categories and subcategories completed!');\r\n          setMessage('üéâ Congratulations! All due cards completed across all categories!');\r\n          \r\n          // Keep the completion message visible longer\r\n          setTimeout(() => setMessage(''), 6000);\r\n        }\r\n      }\r\n    }\r\n  }, [showDueTodayOnly, selectedCategory, selectedSubCategory, filteredFlashcards, allDueCards.length, getNextCategoryWithDueCards, getNextSubCategoryWithLeastCards, getSubCategoryStats, setSelectedCategory, setSelectedSubCategory, setShowDueTodayOnly, lastManualCategoryChange, lastManualSubCategoryChange, lastCardCompletion, isManualCategorySelection, flashcards]);\r\n\r\n  // Debug logging for loading state\r\n  // console.log('App loading state:', {\r\n  //   isFirebaseInitialized,\r\n  //   isAuthReady,\r\n  //   settingsLoaded,\r\n  //   userId,\r\n  //   showLoginScreen\r\n  // });\r\n\r\n  // Show loading screen while initializing\r\n  if (!isFirebaseInitialized || !isAuthReady || !settingsLoaded) {\r\n    return (\r\n      <div className={`app-loading ${isDarkMode ? 'dark' : ''}`}>\r\n        <div className=\"loading-content\">\r\n          <div className=\"loading-spinner\"></div>\r\n          <p>Loading Flashcard App...</p>\r\n          <div style={{ marginTop: '10px', fontSize: '12px', opacity: 0.7 }}>\r\n            <p>Firebase: {isFirebaseInitialized ? '‚úÖ' : '‚è≥'}</p>\r\n            <p>Auth: {isAuthReady ? '‚úÖ' : '‚è≥'}</p>\r\n            <p>Settings: {settingsLoaded ? '‚úÖ' : '‚è≥'}</p>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // Show login screen if not authenticated\r\n  if (showLoginScreen) {\r\n    return (\r\n      <LoginScreen\r\n        handleLogin={(e) => {\r\n          e.preventDefault();\r\n          handleLogin('login', email, password);\r\n        }}\r\n        handleRegister={(e) => {\r\n          e.preventDefault();\r\n          handleLogin('register', email, password);\r\n        }}\r\n        handleAnonymousLogin={() => {\r\n          handleLogin('anonymous');\r\n        }}\r\n        handlePasswordReset={handlePasswordReset}\r\n        authError={authError || error}\r\n        email={email}\r\n        setEmail={setEmail}\r\n        password={password}\r\n        setPassword={setPassword}\r\n        isDarkMode={isDarkMode}\r\n        isLoading={authLoading}\r\n        onToggleDarkMode={toggleDarkMode}\r\n      />\r\n    );\r\n  }\r\n  \r\n  // Convert flashcards to calendar dates format\r\n  const getCalendarDates = () => {\r\n    const dateMap = new Map();\r\n    const completionMap = new Map();\r\n    const now = new Date();\r\n    const todayString = now.toDateString();\r\n    \r\n    // First, count all cards that are due now or earlier and group them by date\r\n    flashcards.forEach(card => {\r\n      // Track completion dates\r\n      if (card.lastReviewed && card.active !== false) {\r\n        const lastReviewDate = card.lastReviewed instanceof Date ? card.lastReviewed : card.lastReviewed.toDate();\r\n        const reviewDateKey = lastReviewDate.toDateString();\r\n        \r\n        if (completionMap.has(reviewDateKey)) {\r\n          completionMap.get(reviewDateKey).completedCount++;\r\n        } else {\r\n          completionMap.set(reviewDateKey, {\r\n            date: new Date(lastReviewDate.getFullYear(), lastReviewDate.getMonth(), lastReviewDate.getDate()),\r\n            completedCount: 1\r\n          });\r\n        }\r\n      }\r\n      \r\n      // Only include active cards with due dates\r\n      if (card.dueDate && card.active !== false) {\r\n        const dueDate = card.dueDate instanceof Date ? card.dueDate : card.dueDate.toDate();\r\n        const dateKey = dueDate.toDateString();\r\n        const isPastDate = dueDate < now && dateKey !== todayString;\r\n        \r\n        // For past dates, preserve historical accuracy by showing what was incomplete\r\n        if (isPastDate) {\r\n          // Past date logic: show what was actually incomplete on that day\r\n          if (dateMap.has(dateKey)) {\r\n            dateMap.get(dateKey).cardCount++;\r\n          } else {\r\n            dateMap.set(dateKey, {\r\n              date: new Date(dueDate.getFullYear(), dueDate.getMonth(), dueDate.getDate()),\r\n              cardCount: 1,\r\n              isPastDate: true\r\n            });\r\n          }\r\n          \r\n          // For past incomplete cards, also count them in today's due cards\r\n          if (dateMap.has(todayString)) {\r\n            if (!dateMap.get(todayString).overdueFromPast) {\r\n              dateMap.get(todayString).overdueFromPast = 0;\r\n            }\r\n            dateMap.get(todayString).overdueFromPast++;\r\n            dateMap.get(todayString).cardCount++;\r\n          } else {\r\n            dateMap.set(todayString, {\r\n              date: new Date(now.getFullYear(), now.getMonth(), now.getDate()),\r\n              cardCount: 1,\r\n              overdueFromPast: 1\r\n            });\r\n          }\r\n        } else {\r\n          // Current/future date logic: show actual current state\r\n          if (dateMap.has(dateKey)) {\r\n            dateMap.get(dateKey).cardCount++;\r\n          } else {\r\n            dateMap.set(dateKey, {\r\n              date: new Date(dueDate.getFullYear(), dueDate.getMonth(), dueDate.getDate()),\r\n              cardCount: 1,\r\n              isPastDate: false\r\n            });\r\n          }\r\n        }\r\n      }\r\n    });\r\n    \r\n    // Merge completion data into calendar dates\r\n    const allDates = Array.from(dateMap.values());\r\n    completionMap.forEach((completion, dateKey) => {\r\n      const existingDate = allDates.find(d => d.date.toDateString() === dateKey);\r\n      if (existingDate) {\r\n        existingDate.completedCount = completion.completedCount;\r\n        \r\n        // For past dates: adjust cardCount to show historical incomplete count\r\n        // This ensures past days show what was actually incomplete, not current state\r\n        if (existingDate.isPastDate) {\r\n          // For past dates, the cardCount represents what was incomplete on that day\r\n          // Don't subtract completions as they represent historical reality\r\n          // The cardCount already represents what was incomplete on that specific day\r\n        }\r\n      } else {\r\n        // Add completion-only dates (days with completions but no current due cards)\r\n        allDates.push({\r\n          date: completion.date,\r\n          cardCount: 0,\r\n          completedCount: completion.completedCount,\r\n          isPastDate: completion.date < now\r\n        });\r\n      }\r\n    });\r\n    \r\n    \r\n    return allDates;\r\n  };\r\n  \r\n  const calendarDates = getCalendarDates();\r\n\r\n  return (\r\n    <div className={`app ${isDarkMode ? 'dark-mode' : ''}`}>\r\n      \r\n      {/* Header */}\r\n      <header className={`app-header ${isHeaderCollapsed ? 'collapsed' : ''}`}>\r\n        <div className={`header-layout ${isHeaderCollapsed ? 'hidden' : ''}`}>\r\n          {/* Left Section - User Welcome */}\r\n          <div className=\"header-left\">\r\n            {userId && userDisplayName && (\r\n              <div className=\"user-welcome-box\">\r\n                <div className=\"welcome-text\">Welcome back!</div>\r\n                <div className=\"user-email\">{userDisplayName}</div>\r\n                <div className=\"streak-info\">\r\n                  üî• {streakDays} day{streakDays !== 1 ? 's' : ''} streak\r\n                </div>\r\n              </div>\r\n            )}\r\n          </div>\r\n\r\n          {/* Left Section - Logo */}\r\n          <div \r\n            className=\"header-left-logo clickable-logo\"\r\n            onClick={() => {\r\n              setShowSettingsModal(true);\r\n              // Toggle interval settings to show FSRS explanation\r\n              if (!showIntervalSettings) {\r\n                toggleIntervalSettings();\r\n              }\r\n            }}\r\n            title=\"Click to learn about FSRS algorithm\"\r\n          >\r\n            <h1 className=\"app-logo\">FSRS Flashcards</h1>\r\n            <p className=\"app-subtitle\">AI Learning Platform</p>\r\n          </div>\r\n\r\n          {/* Right Section - Actions */}\r\n          <div className=\"header-right\">\r\n            <div className=\"actions-toggle-section\">\r\n              {/* Action Buttons */}\r\n              <div className=\"action-buttons\">\r\n                <button\r\n                  className=\"btn btn-secondary\"\r\n                  onClick={() => setShowManageCardsModal(true)}\r\n                  title=\"Manage cards (M)\"\r\n                >\r\n                  üìã Manage Cards\r\n                </button>\r\n\r\n                <button\r\n                  className=\"btn btn-secondary\"\r\n                  onClick={() => setShowCalendarModal(true)}\r\n                  title=\"View calendar\"\r\n                >\r\n                  üìÖ Calendar\r\n                </button>\r\n\r\n                <button\r\n                  className=\"btn btn-secondary\"\r\n                  onClick={() => setShowSettingsModal(true)}\r\n                  title=\"Settings (S)\"\r\n                >\r\n                  ‚öôÔ∏è Settings\r\n                </button>\r\n\r\n                {/* Header Toggle Arrow */}\r\n                <button \r\n                  className=\"header-arrow-toggle\"\r\n                  onClick={() => setIsHeaderCollapsed(!isHeaderCollapsed)}\r\n                  aria-label=\"Collapse header\"\r\n                  title=\"Hide header controls\"\r\n                >\r\n                  ‚ñ≤\r\n                </button>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        \r\n        {/* Show toggle button when header is collapsed */}\r\n        {isHeaderCollapsed && (\r\n          <div className=\"collapsed-header-controls\">\r\n            <button\r\n              className=\"header-toggle-btn-collapsed collapse-toggle header-collapse-toggle\"\r\n              onClick={() => setIsHeaderCollapsed(false)}\r\n              aria-label=\"Expand header\"\r\n              title=\"Show header controls\"\r\n            >\r\n              ‚ñº\r\n            </button>\r\n          </div>\r\n        )}\r\n      </header>\r\n\r\n      {/* Messages */}\r\n      {(message || error || flashcardsError || settingsError) && (\r\n        <div className=\"message-bar\">\r\n          {message && (\r\n            <div className=\"success-message\">\r\n              ‚úÖ {message}\r\n            </div>\r\n          )}\r\n          {(error || flashcardsError || settingsError) && (\r\n            <div className=\"error-message\">\r\n              ‚ùå {error || flashcardsError || settingsError}\r\n              <button className=\"close-message\" onClick={clearError}>√ó</button>\r\n            </div>\r\n          )}\r\n        </div>\r\n      )}\r\n\r\n\r\n      {/* Main Content */}\r\n      <main className=\"app-main\">\r\n        \r\n        {/* Anonymous User Warning */}\r\n        {isAnonymous && !isAnonymousWarningDismissed && (\r\n          <div className=\"anonymous-warning\">\r\n            <div className=\"warning-content\">\r\n              <span className=\"warning-icon\">‚ö†Ô∏è</span>\r\n              <div className=\"warning-text\">\r\n                <strong>Anonymous Session</strong>\r\n                <p>You're using anonymous mode. Your flashcards and progress will not be saved permanently. Consider creating an account to save your progress.</p>\r\n              </div>\r\n              <div className=\"warning-actions\">\r\n                <button \r\n                  className=\"warning-dismiss-btn\"\r\n                  onClick={() => setShowLoginScreen(true)}\r\n                  title=\"Switch to account login\"\r\n                >\r\n                  Sign In\r\n                </button>\r\n                <button \r\n                  className=\"warning-close-btn\"\r\n                  onClick={() => setIsAnonymousWarningDismissed(true)}\r\n                  title=\"Close this warning\"\r\n                >\r\n                  ‚úï\r\n                </button>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        )}\r\n\r\n        {filteredFlashcards.length === 0 ? (\r\n          <div className=\"flashcard-area\">\r\n            <div className=\"flashcard-with-notes-container\">\r\n              {/* Filters Section - Left panel (same as when cards are available) */}\r\n              <div className=\"filters-section-left\">\r\n                <div className=\"filters-group\">\r\n                  {/* Due Cards Panel - Above categories */}\r\n                  <div className=\"filter-section\">\r\n                    <div className=\"card-filter-toggle\">\r\n                      <div className=\"toggle-group primary-toggles\">\r\n                        <button\r\n                          className={`toggle-btn ${!showDueTodayOnly ? 'active' : ''}`}\r\n                          onClick={() => {\r\n                            setShowDueTodayOnly(false);\r\n                            // Keep current filters when switching to all cards\r\n                          }}\r\n                        >\r\n                          All ({flashcards.length})\r\n                        </button>\r\n                        <button\r\n                          className={`toggle-btn ${showDueTodayOnly ? 'active' : ''}`}\r\n                          onClick={() => {\r\n                            setShowDueTodayOnly(true);\r\n                            // Category and subcategory filters are still applied to due cards\r\n                          }}\r\n                          title={`Filtered Due Cards: ${filteredDueCards.length} | Total Due (All Categories): ${allDueCards.length}`}\r\n                        >\r\n                          Today ({filteredDueCards.length})\r\n                        </button>\r\n                      </div>\r\n                      <div className=\"toggle-group filter-toggles\">\r\n                        <button\r\n                          className={`toggle-btn star-toggle ${showStarredOnly ? 'active' : ''}`}\r\n                          onClick={() => {\r\n                            setShowStarredOnly(!showStarredOnly);\r\n                            // Star filter can be combined with either view mode\r\n                          }}\r\n                          title={`Starred Cards: ${starredCardsCount}`}\r\n                        >\r\n                          <span>‚≠ê</span>\r\n                        </button>\r\n                      </div>\r\n                    </div>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n              \r\n              {/* No Cards Content */}\r\n              <div className=\"no-cards-state\">\r\n                {showDueTodayOnly && flashcards.length > 0 && allDueCards.length === 0 ? (\r\n              // All cards completed for today!\r\n              <>\r\n                <div className=\"completion-celebration\">\r\n                  <div style={{ fontSize: '5rem', marginBottom: '1rem', animation: 'bounce 1s ease-in-out' }}>\r\n                    üòä\r\n                  </div>\r\n                  <h2 style={{ color: 'var(--success-color, #4caf50)', marginBottom: '0.5rem' }}>\r\n                    üéâ Congratulations! üéâ\r\n                  </h2>\r\n                  <h3>All cards completed for today!</h3>\r\n                  <p style={{ fontSize: '1.1rem', margin: '1rem 0' }}>\r\n                    You've successfully reviewed all your due cards. \r\n                    Great work on staying consistent! üí™\r\n                  </p>\r\n                  <div className=\"completion-stats\" style={{ \r\n                    margin: '1.5rem 0',\r\n                    padding: '1rem',\r\n                    backgroundColor: 'var(--bg-secondary)',\r\n                    borderRadius: '8px'\r\n                  }}>\r\n                    <p>üìä Today's Stats:</p>\r\n                    <p>‚úÖ Cards reviewed today: {cardsReviewedToday.length}</p>\r\n                    <p>üìñ Total cards: {flashcards.length}</p>\r\n                    <p>üéØ Streak maintained!</p>\r\n                  </div>\r\n                  <div className=\"no-cards-actions\">\r\n                    <button \r\n                      className=\"btn btn-secondary\"\r\n                      onClick={() => setShowDueTodayOnly(false)}\r\n                    >\r\n                      View All Cards\r\n                    </button>\r\n                    <button \r\n                      className=\"btn btn-primary\"\r\n                      onClick={() => setShowCreateCardForm(true)}\r\n                    >\r\n                      Create New Card\r\n                    </button>\r\n                  </div>\r\n                </div>\r\n              </>\r\n            ) : (\r\n              // Regular no cards message with auto-navigation\r\n              <>\r\n                {selectedCategory === 'All' ? (\r\n                  // When \"All\" categories selected and no cards\r\n                  <>\r\n                    <h2>No flashcards available for the current filters.</h2>\r\n                    <p>\r\n                      Try adjusting your filters (category, subcategory, level, due/starred toggles) or\r\n                      <strong>create new flashcards</strong> or <strong>import existing collections</strong> to get started!\r\n                    </p>\r\n                  </>\r\n                ) : (\r\n                  // When specific category selected but no cards - auto-navigate to optimal category/subcategory\r\n                  <AutoNavigateToOptimalCards \r\n                    currentCategory={selectedCategory}\r\n                    currentSubCategory={selectedSubCategory}\r\n                    showDueTodayOnly={showDueTodayOnly}\r\n                    getNextCategoryWithLeastCards={getNextCategoryWithLeastCards}\r\n                    getNextSubCategoryWithLeastCards={getNextSubCategoryWithLeastCards}\r\n                    setSelectedCategory={setSelectedCategory}\r\n                    setSelectedSubCategory={setSelectedSubCategory}\r\n                    setMessage={setMessage}\r\n                  />\r\n                )}\r\n                <div className=\"no-cards-actions\">\r\n                  <button \r\n                    className=\"btn btn-primary\"\r\n                    onClick={() => setShowManageCardsModal(true)}\r\n                  >\r\n                    üìã Manage Cards\r\n                  </button>\r\n                  \r\n                  <button \r\n                    className=\"btn btn-outline\"\r\n                    onClick={() => {\r\n                      setSelectedCategory('All');\r\n                      setSelectedSubCategory('All');\r\n                      setMessage('Switched to All categories');\r\n                      setTimeout(() => setMessage(''), 3000);\r\n                    }}\r\n                  >\r\n                    üìÇ View All Categories\r\n                  </button>\r\n                </div>\r\n              </>\r\n            )}\r\n            </div>\r\n            </div>\r\n          </div>\r\n        ) : (\r\n          <div className=\"flashcard-area\">\r\n            <div className=\"flashcard-with-notes-container\">\r\n              {/* Filters Section - Left of flashcard */}\r\n              <div className=\"filters-section-left\">\r\n                <div className=\"filters-group\">\r\n                  {/* Due Cards Panel - Above categories */}\r\n                  <div className=\"filter-section\">\r\n                    <div className=\"card-filter-toggle\">\r\n                      <div className=\"toggle-group primary-toggles\">\r\n                        <button\r\n                          className={`toggle-btn ${!showDueTodayOnly ? 'active' : ''}`}\r\n                          onClick={() => {\r\n                            setShowDueTodayOnly(false);\r\n                            // Keep current filters when switching to all cards\r\n                          }}\r\n                        >\r\n                          All ({flashcards.length})\r\n                        </button>\r\n                        <button\r\n                          className={`toggle-btn ${showDueTodayOnly ? 'active' : ''}`}\r\n                          onClick={() => {\r\n                            setShowDueTodayOnly(true);\r\n                            // Category and subcategory filters are still applied to due cards\r\n                          }}\r\n                          title={`Filtered Due Cards: ${filteredDueCards.length} | Total Due (All Categories): ${allDueCards.length}`}\r\n                        >\r\n                          Today ({filteredDueCards.length})\r\n                        </button>\r\n                      </div>\r\n                      <div className=\"toggle-group filter-toggles\">\r\n                        <button\r\n                          className={`toggle-btn star-toggle ${showStarredOnly ? 'active' : ''}`}\r\n                          onClick={() => {\r\n                            setShowStarredOnly(!showStarredOnly);\r\n                          }}\r\n                          title={`Show only starred cards: ${showStarredOnly ? 'ON' : 'OFF'}`}\r\n                        >\r\n                          <span>‚≠ê</span>\r\n                        </button>\r\n                      </div>\r\n                    </div>\r\n                  </div>\r\n                  <div className=\"filters-content\">\r\n                    {/* Category Filter Buttons */}\r\n                    {(filteredDisplayCategories.length > 0) && (\r\n                      <div className={`filter-section ${isCategoriesCollapsed ? 'collapsed' : ''}`}>\r\n                        <button\r\n                          className=\"collapse-toggle panel-collapse-toggle\"\r\n                          onClick={() => {\r\n                            console.log('Categories collapse clicked, current state:', isCategoriesCollapsed);\r\n                            setIsCategoriesCollapsed(!isCategoriesCollapsed);\r\n                          }}\r\n                          aria-label={isCategoriesCollapsed ? \"Expand categories\" : \"Collapse categories\"}\r\n                        >\r\n                          {isCategoriesCollapsed ? '‚ñº' : '‚ñ≤'}\r\n                        </button>\r\n                        <div className=\"filter-section-header\">\r\n                          <label className=\"filter-label\">Categories</label>\r\n                        </div>\r\n                        <div className=\"filter-buttons-container\">\r\n                          <button\r\n                            className={`filter-btn ${selectedCategory === 'All' ? 'active' : ''}`}\r\n                            onClick={() => setSelectedCategory('All')}\r\n                          >\r\n                            All ({(() => {\r\n                              // Calculate total count by summing up the actual counts shown for each individual category\r\n                              // This ensures the \"All\" count matches the sum of individual category counts\r\n                              let totalCount = 0;\r\n\r\n                              filteredDisplayCategories.forEach(category => {\r\n                                // Use the EXACT same logic as individual category buttons below\r\n                                let categoryCards = flashcards.filter(card => {\r\n                                  // Only count active cards\r\n                                  if (card.active === false) return false;\r\n                                  // Match the category\r\n                                  return (card.category || 'Uncategorized') === category;\r\n                                });\r\n\r\n                                // Calculate count based on showDueTodayOnly and showStarredOnly\r\n                                let actualCardsInCategory;\r\n                                \r\n                                if (showDueTodayOnly && showStarredOnly) {\r\n                                  // When both filters are on, count actual starred due cards\r\n                                  // Apply starred filter\r\n                                  categoryCards = categoryCards.filter(card => card.starred === true);\r\n                                  \r\n                                  // Apply due date filter\r\n                                  const now = new Date();\r\n                                  const endOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);\r\n                                  categoryCards = categoryCards.filter(card => {\r\n                                    let dueDate = card.dueDate || new Date(0);\r\n                                    if (dueDate && typeof dueDate.toDate === 'function') {\r\n                                      dueDate = dueDate.toDate();\r\n                                    }\r\n                                    return dueDate < endOfToday;\r\n                                  });\r\n                                  \r\n                                  actualCardsInCategory = categoryCards.length;\r\n                                } else if (showDueTodayOnly) {\r\n                                  // Use real-time counting for \"All\" button\r\n                                  const now = new Date();\r\n                                  const endOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);\r\n                                  categoryCards = categoryCards.filter(card => {\r\n                                    let dueDate = card.dueDate || new Date(0);\r\n                                    if (dueDate && typeof dueDate.toDate === 'function') {\r\n                                      dueDate = dueDate.toDate();\r\n                                    }\r\n                                    return dueDate < endOfToday;\r\n                                  });\r\n                                  actualCardsInCategory = categoryCards.length;\r\n                                } else {\r\n                                  // For non-due mode, count actual cards with filters\r\n                                  // If showing starred only, filter by starred\r\n                                  if (showStarredOnly) {\r\n                                    categoryCards = categoryCards.filter(card => card.starred === true);\r\n                                  }\r\n                                  actualCardsInCategory = categoryCards.length;\r\n                                }\r\n\r\n                                // Only add to total if category has cards (same logic as individual buttons)\r\n                                if (actualCardsInCategory > 0) {\r\n                                  totalCount += actualCardsInCategory;\r\n                                }\r\n                              });\r\n                              \r\n                              console.log(`All category TOTAL (corrected): ${totalCount}`);\r\n                              return totalCount;\r\n                            })()})\r\n                          </button>\r\n                          {(() => {\r\n                            // Use filteredDisplayCategories which only includes categories with actual cards\r\n\r\n                            return filteredDisplayCategories.map(category => {\r\n                              // Count actual cards in this category from ALL flashcards (not filtered)\r\n                              // Apply the same base filters as the main filtering logic\r\n                              let categoryCards = flashcards.filter(card => {\r\n                                // Only count active cards\r\n                                if (card.active === false) return false;\r\n                                // Match the category\r\n                                return (card.category || 'Uncategorized') === category;\r\n                              });\r\n\r\n                              // Calculate count based on showDueTodayOnly and showStarredOnly\r\n                              let actualCardsInCategory;\r\n                              \r\n                              if (showDueTodayOnly && showStarredOnly) {\r\n                                // When both filters are on, count actual starred due cards\r\n                                // Apply starred filter\r\n                                categoryCards = categoryCards.filter(card => card.starred === true);\r\n                                \r\n                                // Apply due date filter\r\n                                const now = new Date();\r\n                                const endOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);\r\n                                categoryCards = categoryCards.filter(card => {\r\n                                  let dueDate = card.dueDate || new Date(0);\r\n                                  if (dueDate && typeof dueDate.toDate === 'function') {\r\n                                    dueDate = dueDate.toDate();\r\n                                  }\r\n                                  return dueDate < endOfToday;\r\n                                });\r\n                                \r\n                                actualCardsInCategory = categoryCards.length;\r\n                              } else if (showDueTodayOnly) {\r\n                                // Use real-time counting for categories\r\n                                const now = new Date();\r\n                                const endOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);\r\n                                categoryCards = categoryCards.filter(card => {\r\n                                  let dueDate = card.dueDate || new Date(0);\r\n                                  if (dueDate && typeof dueDate.toDate === 'function') {\r\n                                    dueDate = dueDate.toDate();\r\n                                  }\r\n                                  return dueDate < endOfToday;\r\n                                });\r\n                                actualCardsInCategory = categoryCards.length;\r\n                              } else {\r\n                                // For non-due mode, count actual cards with filters\r\n                                // If showing starred only, filter by starred\r\n                                if (showStarredOnly) {\r\n                                  categoryCards = categoryCards.filter(card => card.starred === true);\r\n                                }\r\n                                actualCardsInCategory = categoryCards.length;\r\n                              }\r\n\r\n                              // Debug logging\r\n                              // console.log(`Individual category DEBUG - ${category}: ${actualCardsInCategory} cards`);\r\n                              \r\n                              // Skip categories with no actual cards\r\n                              if (actualCardsInCategory === 0) {\r\n                                return null;\r\n                              }\r\n                              \r\n                              return (\r\n                                <button\r\n                                  key={category}\r\n                                  className={`filter-btn ${selectedCategory === category ? 'active' : ''}`}\r\n                                  onClick={() => {\r\n                                    console.log(`üîç Manual category selection: \"${category}\"`);\r\n                                    console.log(`üîç Previous selectedCategory: \"${selectedCategory}\"`);\r\n                                    setSelectedCategory(category);\r\n                                    setLastManualCategoryChange(Date.now());\r\n                                    setIsManualCategorySelection(true);\r\n                                    console.log(`üîç setSelectedCategory called with: \"${category}\"`);\r\n\r\n                                    // Clear the manual selection flag after 15 seconds\r\n                                    setTimeout(() => {\r\n                                      setIsManualCategorySelection(false);\r\n                                      console.log(`üîç Manual category selection protection expired for \"${category}\"`);\r\n                                    }, 15000);\r\n                                  }}\r\n                                >\r\n                                  {category} ({actualCardsInCategory})\r\n                                </button>\r\n                              );\r\n                            });\r\n                          })()}\r\n                        </div>\r\n                      </div>\r\n                    )}\r\n\r\n                    {/* Sub-Category Filter Buttons */}\r\n                    {subCategories.length > 0 && (\r\n                      <div className={`filter-section subcategory-section ${isSubCategoriesCollapsed ? 'collapsed' : ''}`}>\r\n                        <button\r\n                          className=\"collapse-toggle panel-collapse-toggle\"\r\n                          onClick={() => {\r\n                            console.log('Subcategories collapse clicked, current state:', isSubCategoriesCollapsed);\r\n                            setIsSubCategoriesCollapsed(!isSubCategoriesCollapsed);\r\n                          }}\r\n                          aria-label={isSubCategoriesCollapsed ? \"Expand subcategories\" : \"Collapse subcategories\"}\r\n                        >\r\n                          {isSubCategoriesCollapsed ? '‚ñº' : '‚ñ≤'}\r\n                        </button>\r\n                        <div className=\"filter-section-header\">\r\n                          <label className=\"filter-label\">Sub-Categories</label>\r\n                        </div>\r\n                        <div className=\"filter-buttons-container\">\r\n                          <button\r\n                            className={`filter-btn ${selectedSubCategory === 'All' ? 'active' : ''}`}\r\n                            onClick={() => {\r\n                              console.log('üîç Manual subcategory selection: \"All\"');\r\n                              setSelectedSubCategory('All');\r\n                              setLastManualSubCategoryChange(Date.now());\r\n                            }}\r\n                          >\r\n                            All\r\n                          </button>\r\n                          {(() => {\r\n                            // Debug sub-categories\r\n                            console.log('üîç App.js subCategories DEBUG:', {\r\n                              selectedCategory,\r\n                              subCategories: subCategories,\r\n                              subCategoriesLength: subCategories.length\r\n                            });\r\n                            \r\n                            // Use filtered subcategories from getSubCategories()\r\n                            return subCategories.map(subCategory => {\r\n                              // Count actual cards in this subcategory from ALL flashcards (not filtered)\r\n                              // Apply the same base filters as the main filtering logic\r\n                              let subCategoryCards = flashcards.filter(card => {\r\n                                // Only count active cards\r\n                                if (card.active === false) return false;\r\n                                // Match the selected category (if not 'All')\r\n                                if (selectedCategory !== 'All' && card.category !== selectedCategory) return false;\r\n                                // Match the subcategory\r\n                                const cardSubCategory = card.sub_category && card.sub_category.trim() ? card.sub_category : 'Uncategorized';\r\n                                return cardSubCategory === subCategory;\r\n                              });\r\n\r\n                              // If showing due cards only, filter by due date\r\n                              if (showDueTodayOnly) {\r\n                                const now = new Date();\r\n                                const endOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);\r\n                                subCategoryCards = subCategoryCards.filter(card => {\r\n                                  let dueDate = card.dueDate || new Date(0);\r\n                                  if (dueDate && typeof dueDate.toDate === 'function') {\r\n                                    dueDate = dueDate.toDate();\r\n                                  }\r\n                                  return dueDate < endOfToday;\r\n                                });\r\n                              }\r\n\r\n                              // If showing starred only, filter by starred\r\n                              if (showStarredOnly) {\r\n                                subCategoryCards = subCategoryCards.filter(card => card.starred === true);\r\n                              }\r\n\r\n                              const actualCardsInSubCategory = subCategoryCards.length;\r\n\r\n                              // Skip subcategories with no actual cards\r\n                              if (actualCardsInSubCategory === 0) {\r\n                                return null;\r\n                              }\r\n                              \r\n                              return (\r\n                                <button\r\n                                  key={subCategory}\r\n                                  className={`filter-btn ${selectedSubCategory === subCategory ? 'active' : ''}`}\r\n                                  onClick={() => {\r\n                                    console.log(`üîç Manual subcategory selection: \"${subCategory}\"`);\r\n                                    setSelectedSubCategory(subCategory);\r\n                                    setLastManualSubCategoryChange(Date.now());\r\n                                  }}\r\n                                >\r\n                                  {subCategory} ({actualCardsInSubCategory})\r\n                                </button>\r\n                              );\r\n                            });\r\n                          })()}\r\n                        </div>\r\n                      </div>\r\n                    )}\r\n\r\n                    {/* Level Filter Buttons */}\r\n                    {levels.length > 0 && (\r\n                      <div className={`filter-section level-section ${isLevelsCollapsed ? 'collapsed' : ''}`}>\r\n                        <button\r\n                          className=\"collapse-toggle panel-collapse-toggle\"\r\n                          onClick={() => {\r\n                            console.log('Levels collapse clicked, current state:', isLevelsCollapsed);\r\n                            setIsLevelsCollapsed(!isLevelsCollapsed);\r\n                          }}\r\n                          aria-label={isLevelsCollapsed ? \"Expand levels\" : \"Collapse levels\"}\r\n                        >\r\n                          {isLevelsCollapsed ? '‚ñº' : '‚ñ≤'}\r\n                        </button>\r\n                        <div className=\"filter-section-header\">\r\n                          <label className=\"filter-label\">Levels</label>\r\n                        </div>\r\n                        <div className=\"filter-buttons-container\">\r\n                          <button\r\n                            className={`filter-btn ${selectedLevel === 'All' ? 'active' : ''}`}\r\n                            onClick={() => setSelectedLevel('All')}\r\n                          >\r\n                            All\r\n                          </button>\r\n                          {levels.map(level => (\r\n                            <button\r\n                              key={level}\r\n                              className={`filter-btn ${selectedLevel === level ? 'active' : ''}`}\r\n                              onClick={() => setSelectedLevel(level)}\r\n                            >\r\n                              {level.charAt(0).toUpperCase() + level.slice(1)}\r\n                            </button>\r\n                          ))}\r\n                        </div>\r\n                      </div>\r\n                    )}\r\n\r\n                  </div>\r\n                </div>\r\n\r\n                {/* Review Panel - Always visible when there's a current card */}\r\n                {currentCard && (\r\n                  <div className=\"review-panel-below-categories\">\r\n                    <div className=\"review-panel-frame\" title=\"Rate Your Knowledge\">\r\n                      <div className=\"review-button-grid\">\r\n                        <button \r\n                          className=\"review-btn again-btn\"\r\n                          onClick={() => handleReviewCard('again')}\r\n                          title=\"Completely forgot (1)\"\r\n                        >\r\n                          <span className=\"btn-number\">1</span>\r\n                          <span className=\"btn-emoji\">üòµ</span>\r\n                          <span className=\"btn-text\">Again</span>\r\n                        </button>\r\n                        \r\n                        <button \r\n                          className=\"review-btn hard-btn\"\r\n                          onClick={() => handleReviewCard('hard')}\r\n                          title=\"Hard to remember (2)\"\r\n                        >\r\n                          <span className=\"btn-number\">2</span>\r\n                          <span className=\"btn-emoji\">üòì</span>\r\n                          <span className=\"btn-text\">Hard</span>\r\n                        </button>\r\n                        \r\n                        <button \r\n                          className=\"review-btn good-btn\"\r\n                          onClick={() => handleReviewCard('good')}\r\n                          title=\"Remembered with effort (3)\"\r\n                        >\r\n                          <span className=\"btn-number\">3</span>\r\n                          <span className=\"btn-emoji\">üòä</span>\r\n                          <span className=\"btn-text\">Good</span>\r\n                        </button>\r\n                        \r\n                        <button \r\n                          className=\"review-btn easy-btn\"\r\n                          onClick={() => handleReviewCard('easy')}\r\n                          title=\"Easy to remember (4)\"\r\n                        >\r\n                          <span className=\"btn-number\">4</span>\r\n                          <span className=\"btn-emoji\">üòé</span>\r\n                          <span className=\"btn-text\">Easy</span>\r\n                        </button>\r\n                      </div>\r\n                    </div>\r\n                  </div>\r\n                )}\r\n\r\n                {/* Progress Bar - Shows daily completion progress using consistent real-time counting */}\r\n                {((cardsCompletedToday + cardsDueToday.length) > 0 || cardsCompletedToday > 0) && (\r\n                  <div className=\"daily-progress-section-wide\">\r\n                    <div className=\"progress-header\">\r\n                      <h4>Daily Progress</h4>\r\n                      <span className=\"progress-stats\">\r\n                        {cardsCompletedToday} / {cardsCompletedToday + cardsDueToday.length} cards completed\r\n                      </span>\r\n                    </div>\r\n                    <div className=\"progress-bar-container\">\r\n                      <div \r\n                        className=\"progress-bar-fill\" \r\n                        style={{ \r\n                          width: `${Math.min(100, (cardsCompletedToday / (cardsCompletedToday + cardsDueToday.length)) * 100)}%` \r\n                        }}\r\n                      />\r\n                    </div>\r\n                    <div className=\"progress-percentage\">\r\n                      {Math.round(Math.min(100, (cardsCompletedToday / (cardsCompletedToday + cardsDueToday.length)) * 100))}%\r\n                    </div>\r\n                  </div>\r\n                )}\r\n              </div>\r\n\r\n              <div className={`flashcard-main-content ${isMaximized || isPopouted ? 'windowed' : ''}`}>\r\n                {/* Overlay for popout mode */}\r\n                {isPopouted && !isMaximized && (\r\n                  <div \r\n                    className=\"popout-overlay\"\r\n                    style={{\r\n                      position: 'fixed',\r\n                      top: 0,\r\n                      left: 0,\r\n                      width: '100vw',\r\n                      height: '100vh',\r\n                      backgroundColor: 'rgba(0, 0, 0, 0.3)',\r\n                      zIndex: 9998\r\n                    }}\r\n                    onClick={handleClosePopout}\r\n                  />\r\n                )}\r\n                \r\n                <div \r\n                  className={`flashcard-window${isMaximized ? ' maximized' : ''}${isPopouted && !isMaximized ? ' popout' : ''}`}\r\n                  style={isMaximized ? {\r\n                    backgroundColor: isDarkMode ? '#1f2937' : '#ffffff',\r\n                  } : isPopouted ? {\r\n                    position: 'fixed',\r\n                    top: windowPosition.y,\r\n                    left: windowPosition.x,\r\n                    width: `${windowSize.width}px`,\r\n                    height: `${windowSize.height}px`,\r\n                    zIndex: 9999,\r\n                    backgroundColor: isDarkMode ? '#1f2937' : '#ffffff',\r\n                    boxShadow: '0 10px 30px rgba(0, 0, 0, 0.3)',\r\n                    borderRadius: '8px',\r\n                    overflow: 'visible', // Changed from 'hidden' to allow resize handles\r\n                    cursor: isDragging ? 'move' : 'default',\r\n                    margin: 'auto',\r\n                    display: 'flex',\r\n                    flexDirection: 'column',\r\n                  } : {\r\n                    position: 'relative',\r\n                    width: '100%',\r\n                    height: 'auto',\r\n                    backgroundColor: isDarkMode ? '#1f2937' : '#ffffff',\r\n                    boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',\r\n                    borderRadius: '8px',\r\n                    overflow: 'hidden',\r\n                    margin: 'auto',\r\n                    display: 'flex',\r\n                    flexDirection: 'column',\r\n                  }}\r\n                >\r\n                  {/* Drag Handle - Only for popout windows */}\r\n                  {isPopouted && !isMaximized && (\r\n                    <div \r\n                      className=\"drag-handle\"\r\n                      onMouseDown={handleMouseDown}\r\n                      style={{\r\n                        position: 'absolute',\r\n                        top: 0,\r\n                        left: 0,\r\n                        right: 0,\r\n                        height: '30px',\r\n                        background: '#f8fafc',\r\n                        borderBottom: '1px solid #e5e7eb',\r\n                        cursor: 'move',\r\n                        zIndex: 10000,\r\n                        display: 'flex',\r\n                        alignItems: 'center',\r\n                        justifyContent: 'center',\r\n                        color: '#64748b',\r\n                        fontSize: '11px',\r\n                        fontWeight: '400',\r\n                        userSelect: 'none'\r\n                      }}\r\n                    >\r\n                      ‚ãÆ‚ãÆ‚ãÆ\r\n                    </div>\r\n                  )}\r\n                  \r\n                  {/* Window Control Buttons - Top Right */}\r\n                  {isMaximized ? (\r\n                    /* Floating Restore Button - Only when maximized */\r\n                    <button\r\n                      onClick={handleRestore}\r\n                      style={{\r\n                        position: 'absolute',\r\n                        top: '16px',\r\n                        right: '16px',\r\n                        zIndex: 10001,\r\n                        padding: '10px 10px',\r\n                        backgroundColor: isDarkMode ? 'rgba(59, 130, 246, 0.3)' : 'rgba(147, 197, 253, 0.9)',\r\n                        border: 'none',\r\n                        borderRadius: '6px',\r\n                        cursor: 'pointer',\r\n                        fontSize: '20px',\r\n                        lineHeight: '1',\r\n                        color: isDarkMode ? '#d1d5db' : '#374151',\r\n                        transition: 'all 0.2s',\r\n                        backdropFilter: 'blur(4px)',\r\n                        boxShadow: '0 2px 8px rgba(0, 0, 0, 0.15)'\r\n                      }}\r\n                      onMouseOver={(e) => {\r\n                        e.target.style.backgroundColor = isDarkMode ? 'rgba(59, 130, 246, 0.5)' : 'rgba(96, 165, 250, 0.9)';\r\n                      }}\r\n                      onMouseOut={(e) => {\r\n                        e.target.style.backgroundColor = isDarkMode ? 'rgba(59, 130, 246, 0.3)' : 'rgba(147, 197, 253, 0.9)';\r\n                      }}\r\n                      title=\"Exit Fullscreen (ESC)\"\r\n                    >\r\n                      ‚ä°\r\n                    </button>\r\n                  ) : isPopouted ? (\r\n                    /* Popout mode - Maximize and Close buttons */\r\n                    <div style={{\r\n                      position: 'absolute',\r\n                      top: '8px',\r\n                      right: '20px',\r\n                      zIndex: 10001,\r\n                      display: 'flex',\r\n                      gap: '4px'\r\n                    }}>\r\n                      <button\r\n                        onClick={handleMaximize}\r\n                        style={{\r\n                          padding: '8px 8px',\r\n                          backgroundColor: isDarkMode ? 'rgba(59, 130, 246, 0.3)' : 'rgba(147, 197, 253, 0.9)',\r\n                          border: 'none',\r\n                          borderRadius: '4px',\r\n                          cursor: 'pointer',\r\n                          fontSize: '18px',\r\n                          lineHeight: '1',\r\n                          color: isDarkMode ? '#d1d5db' : '#374151',\r\n                          transition: 'all 0.2s',\r\n                          backdropFilter: 'blur(4px)',\r\n                          boxShadow: '0 2px 8px rgba(0, 0, 0, 0.15)'\r\n                        }}\r\n                        onMouseOver={(e) => {\r\n                          e.target.style.backgroundColor = isDarkMode ? 'rgba(59, 130, 246, 0.5)' : 'rgba(96, 165, 250, 0.9)';\r\n                        }}\r\n                        onMouseOut={(e) => {\r\n                          e.target.style.backgroundColor = isDarkMode ? 'rgba(59, 130, 246, 0.3)' : 'rgba(147, 197, 253, 0.9)';\r\n                        }}\r\n                        title=\"Maximize to fullscreen\"\r\n                      >\r\n                        ‚õ∂\r\n                      </button>\r\n                      <button\r\n                        onClick={handleRestorePosition}\r\n                        style={{\r\n                          padding: '8px 8px',\r\n                          backgroundColor: isDarkMode ? 'rgba(59, 130, 246, 0.3)' : 'rgba(147, 197, 253, 0.9)',\r\n                          border: 'none',\r\n                          borderRadius: '4px',\r\n                          cursor: 'pointer',\r\n                          fontSize: '18px',\r\n                          lineHeight: '1',\r\n                          color: isDarkMode ? '#d1d5db' : '#374151',\r\n                          transition: 'all 0.2s',\r\n                          backdropFilter: 'blur(4px)',\r\n                          boxShadow: '0 2px 8px rgba(0, 0, 0, 0.15)'\r\n                        }}\r\n                        onMouseOver={(e) => {\r\n                          e.target.style.backgroundColor = isDarkMode ? 'rgba(59, 130, 246, 0.5)' : 'rgba(96, 165, 250, 0.9)';\r\n                        }}\r\n                        onMouseOut={(e) => {\r\n                          e.target.style.backgroundColor = isDarkMode ? 'rgba(59, 130, 246, 0.3)' : 'rgba(147, 197, 253, 0.9)';\r\n                        }}\r\n                        title=\"Close popout and restore to normal view\"\r\n                      >\r\n                        ‚ä°\r\n                      </button>\r\n                    </div>\r\n                  ) : (\r\n                    /* Normal mode - Maximize and Popout buttons */\r\n                    <div style={{\r\n                      position: 'absolute',\r\n                      top: '8px',\r\n                      right: '20px',\r\n                      zIndex: 10001,\r\n                      display: 'flex',\r\n                      gap: '4px'\r\n                    }}>\r\n                      <button\r\n                        onClick={handleMaximize}\r\n                        style={{\r\n                          padding: '8px 8px',\r\n                          backgroundColor: isDarkMode ? 'rgba(59, 130, 246, 0.3)' : 'rgba(147, 197, 253, 0.9)',\r\n                          border: 'none',\r\n                          borderRadius: '4px',\r\n                          cursor: 'pointer',\r\n                          fontSize: '18px',\r\n                          lineHeight: '1',\r\n                          color: isDarkMode ? '#d1d5db' : '#374151',\r\n                          transition: 'all 0.2s',\r\n                          backdropFilter: 'blur(4px)',\r\n                          boxShadow: '0 2px 8px rgba(0, 0, 0, 0.15)'\r\n                        }}\r\n                        onMouseOver={(e) => {\r\n                          e.target.style.backgroundColor = isDarkMode ? 'rgba(59, 130, 246, 0.5)' : 'rgba(96, 165, 250, 0.9)';\r\n                        }}\r\n                        onMouseOut={(e) => {\r\n                          e.target.style.backgroundColor = isDarkMode ? 'rgba(59, 130, 246, 0.3)' : 'rgba(147, 197, 253, 0.9)';\r\n                        }}\r\n                        title=\"Maximize to fullscreen\"\r\n                      >\r\n                        ‚õ∂\r\n                      </button>\r\n                      <button\r\n                        onClick={handlePopout}\r\n                        style={{\r\n                          padding: '8px 8px',\r\n                          backgroundColor: isDarkMode ? 'rgba(59, 130, 246, 0.3)' : 'rgba(147, 197, 253, 0.9)',\r\n                          border: 'none',\r\n                          borderRadius: '4px',\r\n                          cursor: 'pointer',\r\n                          fontSize: '18px',\r\n                          lineHeight: '1',\r\n                          color: isDarkMode ? '#d1d5db' : '#374151',\r\n                          transition: 'all 0.2s',\r\n                          backdropFilter: 'blur(4px)',\r\n                          boxShadow: '0 2px 8px rgba(0, 0, 0, 0.15)'\r\n                        }}\r\n                        onMouseOver={(e) => {\r\n                          e.target.style.backgroundColor = isDarkMode ? 'rgba(59, 130, 246, 0.5)' : 'rgba(96, 165, 250, 0.9)';\r\n                        }}\r\n                        onMouseOut={(e) => {\r\n                          e.target.style.backgroundColor = isDarkMode ? 'rgba(59, 130, 246, 0.3)' : 'rgba(147, 197, 253, 0.9)';\r\n                        }}\r\n                        title=\"Popout window\"\r\n                      >\r\n                        ‚ßâ\r\n                      </button>\r\n                    </div>\r\n                  )}\r\n                  \r\n                  {/* Flashcard Content */}\r\n                  <div\r\n                    className=\"flashcard-content\"\r\n                    style={{\r\n                      flex: 1,\r\n                      minHeight: 0,\r\n                      minWidth: 0,\r\n                      width: '100%',\r\n                      height: '100%',\r\n                      overflow: isMaximized || isPopouted ? 'auto' : 'visible',\r\n                      overflowX: 'hidden',\r\n                      scrollbarWidth: 'thin',\r\n                      scrollbarColor: isDarkMode ? '#6b7280 #374151' : '#d1d5db #f3f4f6',\r\n                      transition: 'height 0.1s ease',\r\n                    }}\r\n                  >\r\n                    <FlashcardDisplay\r\n                      card={currentCard}\r\n                      showAnswer={showAnswer}\r\n                      onShowAnswer={() => setShowAnswer(true)}\r\n                      onToggleAnswer={() => setShowAnswer(!showAnswer)}\r\n                      onPreviousCard={prevCard}\r\n                      onNextCard={nextCard}\r\n                      onReviewCard={handleReviewCard}\r\n                      currentIndex={currentCardIndex}\r\n                      totalCards={filteredFlashcards.length}\r\n                      isDarkMode={isDarkMode}\r\n                      onToggleStarCard={toggleStarCard}\r\n                      onEditCard={handleEditCard}\r\n                      onGenerateQuestions={() => setShowGenerateModal(true)}\r\n                    />\r\n                  </div>\r\n                  \r\n                  {/* Resize Handles - Only show when popouted */}\r\n                  {isPopouted && !isMaximized && (\r\n                    <>\r\n                      {/* Corner handles */}\r\n                      <div className=\"resize-handle resize-nw\" onMouseDown={(e) => handleResizeStart(e, 'nw')} />\r\n                      <div className=\"resize-handle resize-ne\" onMouseDown={(e) => handleResizeStart(e, 'ne')} />\r\n                      <div className=\"resize-handle resize-sw\" onMouseDown={(e) => handleResizeStart(e, 'sw')} />\r\n                      <div className=\"resize-handle resize-se\" onMouseDown={(e) => handleResizeStart(e, 'se')} />\r\n                      \r\n                      {/* Edge handles */}\r\n                      <div className=\"resize-handle resize-n\" onMouseDown={(e) => handleResizeStart(e, 'n')} />\r\n                      <div className=\"resize-handle resize-s\" onMouseDown={(e) => handleResizeStart(e, 's')} />\r\n                      <div className=\"resize-handle resize-e\" onMouseDown={(e) => handleResizeStart(e, 'e')} />\r\n                      <div className=\"resize-handle resize-w\" onMouseDown={(e) => handleResizeStart(e, 'w')} />\r\n                    </>\r\n                  )}\r\n                </div>\r\n              </div>\r\n              \r\n              {/* Right Side Content - Notes and Review Panel */}\r\n              <div className=\"right-side-content\">\r\n                {/* Session Notes - Always visible (unless popped out) */}\r\n                {!isNotesPopouted && (\r\n                <div className={`notes-section-permanent ${isNotesCollapsed ? 'collapsed' : ''}`}>\r\n                  <div className=\"notes-header\">\r\n                    <h4>üìù Notes</h4>\r\n                    <div className=\"notes-header-controls\">\r\n                      <button\r\n                        className=\"explain-btn notes-explain-btn\"\r\n                        onClick={handleOpenExplain}\r\n                        aria-label=\"Generate explanation\"\r\n                        title=\"Generate AI explanation about the current question\"\r\n                      >\r\n                        üí° Explain\r\n                      </button>\r\n                      <button\r\n                        className=\"popout-btn notes-popout-btn\"\r\n                        onClick={handleNotesPopout}\r\n                        aria-label=\"Pop out notes\"\r\n                        title=\"Pop out notes to separate window\"\r\n                      >\r\n                        ‚¨ú\r\n                      </button>\r\n                      <button\r\n                        className=\"collapse-toggle notes-collapse-toggle\"\r\n                        onClick={() => {\r\n                          console.log('Notes collapse clicked, current state:', isNotesCollapsed);\r\n                          setIsNotesCollapsed(!isNotesCollapsed);\r\n                        }}\r\n                        aria-label={isNotesCollapsed ? \"Expand notes\" : \"Collapse notes\"}\r\n                      >\r\n                        {isNotesCollapsed ? '‚ñº' : '‚ñ≤'}\r\n                      </button>\r\n                    </div>\r\n                  </div>\r\n                  \r\n                  <div className=\"notes-content\">\r\n                    <div className=\"notes-content-wrapper\">\r\n                      <div className=\"notes-editor-container\">\r\n                        <RichTextEditor\r\n                          value={notes}\r\n                          onChange={handleNotesChange}\r\n                          placeholder=\"Take notes for your study session...\"\r\n                          className=\"notes-textarea-permanent\"\r\n                          minHeight=\"700px\"\r\n                        />\r\n                      </div>\r\n                    </div>\r\n                  </div>\r\n                  \r\n                  <div className=\"notes-footer\">\r\n                      <button \r\n                        className=\"notes-footer-btn copy-btn\"\r\n                        onClick={() => {\r\n                          // Copy notes content to clipboard\r\n                          const tempDiv = document.createElement('div');\r\n                          tempDiv.innerHTML = notes;\r\n                          const textContent = tempDiv.textContent || tempDiv.innerText || '';\r\n                          navigator.clipboard.writeText(textContent).then(() => {\r\n                            setNotesCopied(true);\r\n                            setTimeout(() => setNotesCopied(false), 2000);\r\n                          }).catch(err => {\r\n                            console.error('Failed to copy notes:', err);\r\n                          });\r\n                        }}\r\n                        disabled={notes.length === 0}\r\n                        title=\"Copy notes to clipboard\"\r\n                      >\r\n                        {notesCopied ? '‚úÖ Copied!' : 'üìã Copy'}\r\n                      </button>\r\n                      <button \r\n                        className=\"notes-footer-btn save-btn\"\r\n                        onClick={() => {\r\n                          // Save notes to local storage or trigger save\r\n                          if (userId) {\r\n                            localStorage.setItem(`flashcard_notes_${userId}`, notes);\r\n                            setNotesSaved(true);\r\n                            setTimeout(() => setNotesSaved(false), 2000);\r\n                          }\r\n                        }}\r\n                        title=\"Save notes\"\r\n                      >\r\n                        {notesSaved ? '‚úÖ Saved!' : 'üíæ Save'}\r\n                      </button>\r\n                      <button \r\n                        className=\"notes-footer-btn clear-btn\"\r\n                        onClick={() => {\r\n                          if (window.confirm('Are you sure you want to clear all notes? This action cannot be undone.')) {\r\n                            handleClearNotes();\r\n                          }\r\n                        }}\r\n                        disabled={notes.length === 0}\r\n                        title=\"Clear all notes\"\r\n                      >\r\n                        üóëÔ∏è Clear\r\n                      </button>\r\n                  </div>\r\n                </div>\r\n                )}\r\n              </div>\r\n            </div>\r\n          </div>\r\n        )}\r\n      </main>\r\n\r\n      {/* Footer */}\r\n      <footer className=\"app-footer\">\r\n        <div className=\"footer-stats\">\r\n          <span>Total Cards: {flashcards.length}</span>\r\n          <span>Filtered: {filteredFlashcards.length}</span>\r\n          <span>Categories: {categories.length}</span>\r\n          <span style={{ color: pastDueCards.length > 0 ? '#ff6b6b' : 'inherit' }}>\r\n            Past Due: {pastDueCards.length}\r\n          </span>\r\n          <span style={{ color: cardsDueToday.length > 0 ? '#feca57' : 'inherit' }}>\r\n            Due Today: {cardsDueToday.length}\r\n          </span>\r\n        </div>\r\n        <div className=\"footer-shortcuts\">\r\n          <small>\r\n            Shortcuts: <kbd>Space</kbd> Show Answer | <kbd>‚Üê/‚Üí</kbd> Navigate | \r\n            <kbd>1-4</kbd> Rate Card | <kbd>C</kbd> Create | <kbd>S</kbd> Settings | <kbd>E</kbd> Export | <kbd>M</kbd> Manage\r\n          </small>\r\n        </div>\r\n      </footer>\r\n\r\n      {/* Notes Popout Window */}\r\n      {isNotesPopouted && (\r\n        <>\r\n          {/* Overlay for notes popout */}\r\n          <div \r\n            className=\"notes-popout-overlay\"\r\n            style={{\r\n              position: 'fixed',\r\n              top: 0,\r\n              left: 0,\r\n              width: '100vw',\r\n              height: '100vh',\r\n              backgroundColor: 'rgba(0, 0, 0, 0.3)',\r\n              zIndex: 9990\r\n            }}\r\n            onClick={handleCloseNotesPopout}\r\n          />\r\n          \r\n          {/* Notes popout window */}\r\n          <div \r\n            className=\"notes-popout-window\"\r\n            style={{\r\n              position: 'fixed',\r\n              left: `${notesWindowPosition.x}px`,\r\n              top: `${notesWindowPosition.y}px`,\r\n              width: `${notesWindowSize.width}px`,\r\n              height: `${notesWindowSize.height}px`,\r\n              backgroundColor: isDarkMode ? '#1e293b' : '#ffffff',\r\n              boxShadow: '0 10px 30px rgba(0, 0, 0, 0.2)',\r\n              borderRadius: '8px',\r\n              border: `1px solid ${isDarkMode ? '#475569' : '#e5e7eb'}`,\r\n              zIndex: 9991,\r\n              display: 'flex',\r\n              flexDirection: 'column',\r\n              overflow: 'hidden'\r\n            }}\r\n          >\r\n            {/* Drag handle */}\r\n            <div \r\n              className=\"notes-drag-handle\"\r\n              onMouseDown={handleNotesMouseDown}\r\n              style={{\r\n                height: '40px',\r\n                background: isDarkMode ? '#334155' : '#f8fafc',\r\n                borderBottom: `1px solid ${isDarkMode ? '#475569' : '#e5e7eb'}`,\r\n                cursor: 'move',\r\n                display: 'flex',\r\n                alignItems: 'center',\r\n                justifyContent: 'space-between',\r\n                padding: '0 1rem',\r\n                userSelect: 'none'\r\n              }}\r\n            >\r\n              <h3 style={{ margin: 0, fontSize: '1.1rem', color: isDarkMode ? '#f1f5f9' : '#1e293b' }}>\r\n                üìù Notes\r\n              </h3>\r\n              <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>\r\n                <button\r\n                  className=\"explain-btn notes-explain-btn-popout\"\r\n                  onClick={handleOpenExplain}\r\n                  style={{\r\n                    background: 'rgba(255, 255, 255, 0.2)',\r\n                    border: '1px solid rgba(255, 255, 255, 0.3)',\r\n                    color: isDarkMode ? '#f1f5f9' : '#1e293b',\r\n                    padding: '0.25rem 0.5rem',\r\n                    borderRadius: '0.25rem',\r\n                    cursor: 'pointer',\r\n                    fontSize: '0.875rem',\r\n                    transition: 'all 0.2s ease'\r\n                  }}\r\n                  aria-label=\"Generate explanation\"\r\n                  title=\"Generate AI explanation about the current question\"\r\n                >\r\n                  üí° Explain\r\n                </button>\r\n                <button\r\n                  className=\"close-btn\"\r\n                  onClick={handleCloseNotesPopout}\r\n                  style={{\r\n                    background: 'none',\r\n                    border: 'none',\r\n                    fontSize: '1.5rem',\r\n                    cursor: 'pointer',\r\n                    color: isDarkMode ? '#94a3b8' : '#64748b',\r\n                    padding: '0 0.5rem'\r\n                  }}\r\n                  aria-label=\"Close notes window\"\r\n                >\r\n                  √ó\r\n                </button>\r\n              </div>\r\n            </div>\r\n            \r\n            {/* Notes content */}\r\n            <div style={{ flex: 1, padding: '1rem', overflow: 'auto' }}>\r\n              <RichTextEditor\r\n                value={notes}\r\n                onChange={handleNotesChange}\r\n                placeholder=\"Take notes for your study session...\"\r\n                className=\"notes-textarea-popout\"\r\n                minHeight=\"100%\"\r\n              />\r\n            </div>\r\n            \r\n            {/* Notes actions */}\r\n            <div style={{\r\n              padding: '1rem',\r\n              borderTop: `1px solid ${isDarkMode ? '#475569' : '#e5e7eb'}`,\r\n              display: 'flex',\r\n              gap: '0.5rem',\r\n              justifyContent: 'flex-end'\r\n            }}>\r\n              <button \r\n                className=\"notes-action-btn\"\r\n                onClick={() => {\r\n                  // Copy notes content to clipboard\r\n                  const tempDiv = document.createElement('div');\r\n                  tempDiv.innerHTML = notes;\r\n                  const textContent = tempDiv.textContent || tempDiv.innerText || '';\r\n                  navigator.clipboard.writeText(textContent).then(() => {\r\n                    setNotesCopied(true);\r\n                    setTimeout(() => setNotesCopied(false), 2000);\r\n                  }).catch(err => {\r\n                    console.error('Failed to copy notes:', err);\r\n                  });\r\n                }}\r\n                disabled={notes.length === 0}\r\n                style={{\r\n                  padding: '0.5rem 1rem',\r\n                  borderRadius: '0.375rem',\r\n                  border: `1px solid ${isDarkMode ? '#475569' : '#e5e7eb'}`,\r\n                  background: isDarkMode ? '#475569' : '#f3f4f6',\r\n                  color: isDarkMode ? '#f1f5f9' : '#374151',\r\n                  cursor: 'pointer'\r\n                }}\r\n              >\r\n                {notesCopied ? '‚úÖ Copied!' : 'üìã Copy'}\r\n              </button>\r\n              <button \r\n                className=\"notes-action-btn\"\r\n                onClick={() => {\r\n                  // Save notes to local storage or trigger save\r\n                  if (userId) {\r\n                    localStorage.setItem(`flashcard_notes_${userId}`, notes);\r\n                    setNotesSaved(true);\r\n                    setTimeout(() => setNotesSaved(false), 2000);\r\n                  }\r\n                }}\r\n                style={{\r\n                  padding: '0.5rem 1rem',\r\n                  borderRadius: '0.375rem',\r\n                  border: `1px solid ${isDarkMode ? '#475569' : '#e5e7eb'}`,\r\n                  background: isDarkMode ? '#475569' : '#f3f4f6',\r\n                  color: isDarkMode ? '#f1f5f9' : '#374151',\r\n                  cursor: 'pointer'\r\n                }}\r\n              >\r\n                {notesSaved ? '‚úÖ Saved!' : 'üíæ Save'}\r\n              </button>\r\n              <button \r\n                className=\"notes-action-btn\"\r\n                onClick={() => {\r\n                  if (window.confirm('Are you sure you want to clear all notes? This action cannot be undone.')) {\r\n                    handleClearNotes();\r\n                  }\r\n                }}\r\n                disabled={notes.length === 0}\r\n                style={{\r\n                  padding: '0.5rem 1rem',\r\n                  borderRadius: '0.375rem',\r\n                  border: `1px solid ${isDarkMode ? '#475569' : '#e5e7eb'}`,\r\n                  background: notes.length === 0 ? (isDarkMode ? '#374151' : '#f9fafb') : (isDarkMode ? '#dc2626' : '#fee2e2'),\r\n                  color: notes.length === 0 ? (isDarkMode ? '#6b7280' : '#9ca3af') : (isDarkMode ? '#fecaca' : '#dc2626'),\r\n                  cursor: notes.length === 0 ? 'not-allowed' : 'pointer',\r\n                  opacity: notes.length === 0 ? 0.5 : 1\r\n                }}\r\n                title=\"Clear all notes\"\r\n              >\r\n                üóëÔ∏è Clear\r\n              </button>\r\n            </div>\r\n            \r\n            {/* Resize handles */}\r\n            <div className=\"resize-handle resize-n\" onMouseDown={(e) => handleNotesResizeStart(e, 'n')} />\r\n            <div className=\"resize-handle resize-ne\" onMouseDown={(e) => handleNotesResizeStart(e, 'ne')} />\r\n            <div className=\"resize-handle resize-e\" onMouseDown={(e) => handleNotesResizeStart(e, 'e')} />\r\n            <div className=\"resize-handle resize-se\" onMouseDown={(e) => handleNotesResizeStart(e, 'se')} />\r\n            <div className=\"resize-handle resize-s\" onMouseDown={(e) => handleNotesResizeStart(e, 's')} />\r\n            <div className=\"resize-handle resize-sw\" onMouseDown={(e) => handleNotesResizeStart(e, 'sw')} />\r\n            <div className=\"resize-handle resize-w\" onMouseDown={(e) => handleNotesResizeStart(e, 'w')} />\r\n            <div className=\"resize-handle resize-nw\" onMouseDown={(e) => handleNotesResizeStart(e, 'nw')} />\r\n          </div>\r\n        </>\r\n      )}\r\n\r\n      {/* Explain Modal */}\r\n      {showExplainModal && (\r\n        <div className=\"modal-overlay\">\r\n          <div className=\"modal-content explain-modal\" style={{ \r\n            backgroundColor: isDarkMode ? '#1e293b' : 'white', \r\n            color: isDarkMode ? '#f1f5f9' : '#1f2937',\r\n            maxWidth: '600px',\r\n            width: '90%'\r\n          }}>\r\n            <div className=\"modal-header\">\r\n              <h2>üí° Generate Explanation</h2>\r\n              <button \r\n                className=\"close-btn\"\r\n                onClick={handleCloseExplain}\r\n                aria-label=\"Close modal\"\r\n              >\r\n                √ó\r\n              </button>\r\n            </div>\r\n\r\n            <div className=\"explain-content\" style={{ padding: '1.5rem' }}>\r\n              <div style={{ marginBottom: '1rem' }}>\r\n                <label \r\n                  htmlFor=\"explain-prompt\" \r\n                  style={{ \r\n                    display: 'block', \r\n                    marginBottom: '0.5rem', \r\n                    fontWeight: '600',\r\n                    color: isDarkMode ? '#f1f5f9' : '#374151'\r\n                  }}\r\n                >\r\n                  What would you like me to explain?\r\n                </label>\r\n                <textarea\r\n                  id=\"explain-prompt\"\r\n                  value={explainPrompt}\r\n                  onChange={(e) => setExplainPrompt(e.target.value)}\r\n                  placeholder=\"Explain the current topic including concepts and why it is important to know...\"\r\n                  style={{\r\n                    width: '100%',\r\n                    minHeight: '100px',\r\n                    padding: '0.75rem',\r\n                    border: `1px solid ${isDarkMode ? '#475569' : '#e5e7eb'}`,\r\n                    borderRadius: '0.5rem',\r\n                    backgroundColor: isDarkMode ? '#374151' : '#ffffff',\r\n                    color: isDarkMode ? '#f1f5f9' : '#374151',\r\n                    fontSize: '0.95rem',\r\n                    lineHeight: '1.5',\r\n                    resize: 'vertical',\r\n                    fontFamily: 'inherit'\r\n                  }}\r\n                  rows={4}\r\n                />\r\n              </div>\r\n\r\n              {/* Checkbox to add explanation to question */}\r\n              <div style={{ marginBottom: '1rem' }}>\r\n                <label style={{ \r\n                  display: 'flex', \r\n                  alignItems: 'center', \r\n                  gap: '0.5rem',\r\n                  cursor: 'pointer',\r\n                  fontSize: '0.95rem',\r\n                  color: isDarkMode ? '#f1f5f9' : '#374151'\r\n                }}>\r\n                  <input\r\n                    type=\"checkbox\"\r\n                    checked={addExplanationToQuestion}\r\n                    onChange={(e) => setAddExplanationToQuestion(e.target.checked)}\r\n                    style={{\r\n                      width: '16px',\r\n                      height: '16px',\r\n                      cursor: 'pointer'\r\n                    }}\r\n                  />\r\n                  Add to question\r\n                </label>\r\n              </div>\r\n\r\n              {explainError && (\r\n                <div style={{\r\n                  color: '#dc2626',\r\n                  backgroundColor: isDarkMode ? 'rgba(220, 38, 38, 0.1)' : 'rgba(220, 38, 38, 0.05)',\r\n                  border: '1px solid rgba(220, 38, 38, 0.2)',\r\n                  borderRadius: '0.375rem',\r\n                  padding: '0.75rem',\r\n                  marginBottom: '1rem',\r\n                  fontSize: '0.875rem'\r\n                }}>\r\n                  ‚ùå {explainError}\r\n                </div>\r\n              )}\r\n\r\n            </div>\r\n\r\n            <div className=\"modal-actions\" style={{ \r\n              padding: '1rem 1.5rem', \r\n              borderTop: `1px solid ${isDarkMode ? '#475569' : '#e5e7eb'}`,\r\n              display: 'flex',\r\n              gap: '0.75rem',\r\n              justifyContent: 'flex-end'\r\n            }}>\r\n              <button \r\n                className=\"btn btn-secondary\"\r\n                onClick={handleCloseExplain}\r\n                disabled={isGeneratingExplanation}\r\n                style={{\r\n                  padding: '0.75rem 1.5rem',\r\n                  borderRadius: '0.5rem',\r\n                  border: `1px solid ${isDarkMode ? '#475569' : '#e5e7eb'}`,\r\n                  backgroundColor: isDarkMode ? '#374151' : '#f3f4f6',\r\n                  color: isDarkMode ? '#f1f5f9' : '#374151',\r\n                  cursor: 'pointer'\r\n                }}\r\n              >\r\n                Cancel\r\n              </button>\r\n              <button \r\n                className=\"btn btn-primary\"\r\n                onClick={handleGenerateExplanation}\r\n                disabled={isGeneratingExplanation || !explainPrompt.trim()}\r\n                style={{\r\n                  padding: '0.75rem 1.5rem',\r\n                  borderRadius: '0.5rem',\r\n                  border: 'none',\r\n                  backgroundColor: isGeneratingExplanation || !explainPrompt.trim() ? '#9ca3af' : '#3b82f6',\r\n                  color: 'white',\r\n                  cursor: isGeneratingExplanation || !explainPrompt.trim() ? 'not-allowed' : 'pointer',\r\n                  display: 'flex',\r\n                  alignItems: 'center',\r\n                  gap: '0.5rem'\r\n                }}\r\n              >\r\n                {isGeneratingExplanation ? (\r\n                  <>\r\n                    <div style={{\r\n                      width: '16px',\r\n                      height: '16px',\r\n                      border: '2px solid transparent',\r\n                      borderTop: '2px solid white',\r\n                      borderRadius: '50%',\r\n                      animation: 'spin 1s linear infinite'\r\n                    }} />\r\n                    Generating...\r\n                  </>\r\n                ) : (\r\n                  <>üß† Generate Explanation</>\r\n                )}\r\n              </button>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      )}\r\n\r\n      {/* Modals */}\r\n      <FlashcardForm\r\n        isVisible={showCreateCardForm}\r\n        onClose={() => {\r\n          setShowCreateCardForm(false);\r\n          setIsEditingCard(false);\r\n          setEditCardData(null);\r\n        }}\r\n        onSubmit={isEditingCard ? handleUpdateCard : handleCreateCard}\r\n        onDelete={handleDeleteCard}\r\n        editCard={editCardData}\r\n        categories={categories}\r\n        isDarkMode={isDarkMode}\r\n        isLoading={flashcardsLoading}\r\n        apiKeys={apiKeys}\r\n        selectedProvider={selectedProvider}\r\n      />\r\n\r\n      <SettingsModal\r\n        isVisible={showSettingsModal}\r\n        onClose={() => setShowSettingsModal(false)}\r\n        isDarkMode={isDarkMode}\r\n        onToggleDarkMode={toggleDarkMode}\r\n        fsrsParams={fsrsParams}\r\n        onUpdateFsrsParams={updateFsrsParams}\r\n        showIntervalSettings={showIntervalSettings}\r\n        onToggleIntervalSettings={toggleIntervalSettings}\r\n        onSignOut={handleSignOut}\r\n        userDisplayName={userDisplayName}\r\n        flashcards={flashcards}\r\n        apiKeys={apiKeys}\r\n        selectedProvider={selectedProvider}\r\n        onApiKeysUpdate={handleApiKeysUpdate}\r\n      />\r\n\r\n      <ImportExportModal\r\n        isVisible={showImportExportModal}\r\n        onClose={() => setShowImportExportModal(false)}\r\n        flashcards={flashcards}\r\n        onImport={handleImport}\r\n        isDarkMode={isDarkMode}\r\n      />\r\n\r\n      <Calendar\r\n        isVisible={showCalendarModal}\r\n        onClose={() => setShowCalendarModal(false)}\r\n        calendarDates={calendarDates}\r\n        isDarkMode={isDarkMode}\r\n      />\r\n\r\n      <GenerateQuestionsModal\r\n        isVisible={showGenerateModal}\r\n        onClose={() => setShowGenerateModal(false)}\r\n        currentCard={currentCard}\r\n        onGenerateQuestions={handleGenerateQuestions}\r\n        isDarkMode={isDarkMode}\r\n        apiKeys={apiKeys}\r\n        selectedProvider={selectedProvider}\r\n      />\r\n\r\n      <ManageCardsModal\r\n        isVisible={showManageCardsModal}\r\n        onClose={() => setShowManageCardsModal(false)}\r\n        flashcards={flashcards}\r\n        onToggleActive={handleToggleCardActive}\r\n        onCreateCard={() => {\r\n          setShowManageCardsModal(false);\r\n          setShowCreateCardForm(true);\r\n        }}\r\n        onImportExport={() => {\r\n          setShowManageCardsModal(false);\r\n          setShowImportExportModal(true);\r\n        }}\r\n        isDarkMode={isDarkMode}\r\n      />\r\n\r\n      {/* Loading Overlay */}\r\n      {(authLoading || flashcardsLoading || settingsLoading) && (\r\n        <div className=\"loading-overlay\">\r\n          <div className=\"loading-spinner\"></div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;",
    "usedDeprecatedRules": [
      {
        "ruleId": "dot-location",
        "replacedBy": []
      },
      {
        "ruleId": "new-parens",
        "replacedBy": []
      },
      {
        "ruleId": "no-mixed-operators",
        "replacedBy": []
      },
      {
        "ruleId": "no-new-object",
        "replacedBy": [
          "no-object-constructor"
        ]
      },
      {
        "ruleId": "no-whitespace-before-property",
        "replacedBy": []
      },
      {
        "ruleId": "rest-spread-spacing",
        "replacedBy": []
      }
    ]
  },
  {
    "filePath": "C:\\Users\\micha\\Documents\\dev\\august\\FLASCARD-APP\\src\\RichTextEditor.jsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      {
        "ruleId": "dot-location",
        "replacedBy": []
      },
      {
        "ruleId": "new-parens",
        "replacedBy": []
      },
      {
        "ruleId": "no-mixed-operators",
        "replacedBy": []
      },
      {
        "ruleId": "no-new-object",
        "replacedBy": [
          "no-object-constructor"
        ]
      },
      {
        "ruleId": "no-whitespace-before-property",
        "replacedBy": []
      },
      {
        "ruleId": "rest-spread-spacing",
        "replacedBy": []
      }
    ]
  },
  {
    "filePath": "C:\\Users\\micha\\Documents\\dev\\august\\FLASCARD-APP\\src\\components\\FlashcardForm.jsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      {
        "ruleId": "dot-location",
        "replacedBy": []
      },
      {
        "ruleId": "new-parens",
        "replacedBy": []
      },
      {
        "ruleId": "no-mixed-operators",
        "replacedBy": []
      },
      {
        "ruleId": "no-new-object",
        "replacedBy": [
          "no-object-constructor"
        ]
      },
      {
        "ruleId": "no-whitespace-before-property",
        "replacedBy": []
      },
      {
        "ruleId": "rest-spread-spacing",
        "replacedBy": []
      }
    ]
  },
  {
    "filePath": "C:\\Users\\micha\\Documents\\dev\\august\\FLASCARD-APP\\src\\components\\StudyGuideModal.jsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      {
        "ruleId": "dot-location",
        "replacedBy": []
      },
      {
        "ruleId": "new-parens",
        "replacedBy": []
      },
      {
        "ruleId": "no-mixed-operators",
        "replacedBy": []
      },
      {
        "ruleId": "no-new-object",
        "replacedBy": [
          "no-object-constructor"
        ]
      },
      {
        "ruleId": "no-whitespace-before-property",
        "replacedBy": []
      },
      {
        "ruleId": "rest-spread-spacing",
        "replacedBy": []
      }
    ]
  }
]