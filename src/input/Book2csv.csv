1,JVM & Memory,Explain the different types of garbage collectors in Java and when to use each,G1GC (Garbage First): Best for applications with large heaps (>4GB) requiring low latency. Uses region-based collection.,"Choose based on heap size, latency requirements, and throughput needs"
,,,,
,,,Parallel GC: Default for server applications. Good throughput but higher pause times. Uses multiple threads for both young and old generation.,
,,,,
,,,CMS (Concurrent Mark Sweep): Low-latency collector for old generation. Deprecated in Java 14. Good for applications requiring short pause times.,
,,,,
,,,ZGC (Z Garbage Collector): Ultra-low latency collector supporting very large heaps (up to 16TB). Available from Java 11+.,
,,,,
,,,Shenandoah: Low-pause collector that performs collection work concurrently with application threads.,
2,Concurrency,"What is the difference between synchronized, volatile, and atomic variables?",synchronized: Provides mutual exclusion and memory visibility. Blocks other threads from accessing the synchronized block/method.,"Use volatile for flags, atomic for counters, synchronized for complex operations"
,,,,
,,,volatile: Ensures memory visibility across threads but doesn't provide atomicity for compound operations. Prevents instruction reordering.,
,,,,
,,,"Atomic variables: Thread-safe operations without locking using compare-and-swap (CAS). Examples: AtomicInteger, AtomicReference.",
,,,,
,,,Key differences:,
,,,"- synchronized: Heavyweight, provides both atomicity and visibility",
,,,"- volatile: Lightweight, provides only visibility",
,,,"- atomic: Lock-free, provides both atomicity and visibility for specific operations",
3,Design Patterns,Implement the Singleton pattern that is thread-safe and efficient,public class Singleton { private static volatile Singleton instance; private Singleton() {} public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } } // Alternative: Enum Singleton (recommended) public enum SingletonEnum { INSTANCE; public void doSomething() { // implementation } },Double-checked locking pattern with volatile keyword. Enum approach is simpler and thread-safe by default
4,Spring Framework,Explain the different types of dependency injection in Spring and their pros/cons,Constructor Injection:,Constructor injection is recommended as best practice
,,,@Component public class UserService { private final UserRepository repository; public UserService(UserRepository repository) { this.repository = repository; } },
,,,"Pros: Immutable dependencies, fail-fast, required dependencies",
,,,Cons: Can lead to constructor parameter bloat,
,,,,
,,,Setter Injection:,
,,,@Component public class UserService { @Autowired private UserRepository repository; public void setRepository(UserRepository repository) { this.repository = repository; } },
,,,"Pros: Optional dependencies, readable",
,,,"Cons: Mutable dependencies, can lead to incomplete objects",
,,,,
,,,Field Injection:,
,,,@Component public class UserService { @Autowired private UserRepository repository; },
,,,Pros: Concise,
,,,"Cons: Hard to test, reflection-based, tight coupling",
5,Concurrency,"Explain the CountDownLatch, CyclicBarrier, and Semaphore. When would you use each?",CountDownLatch: One-time synchronization primitive. Threads wait until a count reaches zero.,"Choose based on whether synchronization is one-time, cyclic, or resource-limiting"
,,,"CountDownLatch latch = new CountDownLatch(3); // Workers count down, main thread waits latch.await(); // blocks until count = 0 latch.countDown(); // decrements count",
,,,Use case: Wait for multiple tasks to complete before proceeding,
,,,,
,,,CyclicBarrier: Reusable synchronization point where threads wait for each other.,
,,,CyclicBarrier barrier = new CyclicBarrier(3); barrier.await(); // threads wait for each other,
,,,Use case: Parallel algorithms where threads need to synchronize at phases,
,,,,
,,,Semaphore: Controls access to a resource pool.,
,,,Semaphore semaphore = new Semaphore(2); semaphore.acquire(); // acquire permit semaphore.release(); // release permit,
,,,Use case: Limiting concurrent access to resources,
6,JVM Internals,Describe the Java memory model and how it affects multithreading,The Java Memory Model (JMM) defines how threads interact through memory:,Understanding JMM is crucial for writing correct concurrent code
,,,,
,,,"Main Memory: Shared among all threads, contains master copy of variables",
,,,,
,,,Thread Local Memory: Each thread has local cache of variables,
,,,,
,,,Happens-Before Relationship: Establishes ordering guarantees:,
,,,- Program order rule,
,,,- Monitor lock rule (synchronized),
,,,- Volatile variable rule,
,,,- Thread start/join rules,
,,,,
,,,Problems without proper synchronization:,
,,,- Visibility issues: Changes by one thread not visible to others,
,,,- Reordering: JVM/CPU can reorder instructions for optimization,
,,,,
,,,Solutions:,
,,,- synchronized keyword,
,,,- volatile variables,
,,,- java.util.concurrent utilities,
,,,- Final fields (immutable after construction),
7,Performance,What are the best practices for Java performance optimization?,JVM Tuning:,"Profile first, optimize based on actual bottlenecks, not assumptions"
,,,- Choose appropriate GC algorithm,
,,,"- Set heap size (-Xms, -Xmx)",
,,,- Tune GC parameters,
,,,- Use JVM profiling tools,
,,,,
,,,Code Optimization:,
,,,- Avoid premature optimization,
,,,- Use StringBuilder for string concatenation,
,,,- Minimize object creation in loops,
,,,- Use appropriate data structures (ArrayList vs LinkedList),
,,,- Cache expensive computations,
,,,,
,,,Memory Management:,
,,,"- Avoid memory leaks (listeners, caches)",
,,,- Use object pools for expensive objects,
,,,- Minimize autoboxing/unboxing,
,,,- Use primitive collections when appropriate,
,,,,
,,,Concurrency:,
,,,- Use thread pools instead of creating threads,
,,,- Minimize synchronization scope,
,,,- Use lock-free data structures,
,,,- Consider async programming,
8,Streams & Lambda,What are the differences between intermediate and terminal operations in Java Streams?,Intermediate Operations:,Intermediate operations are lazy and chainable; terminal operations trigger execution
,,,- Lazy evaluation (not executed until terminal operation),
,,,- Return a Stream,
,,,- Can be chained,
,,,"- Examples: filter(), map(), sorted(), distinct()",
,,,,
,,,Stream<String> stream = list.stream() .filter(s -> s.length() > 3) // intermediate .map(String::toUpperCase); // intermediate,
,,,,
,,,Terminal Operations:,
,,,- Trigger stream processing,
,,,- Return non-Stream result or void,
,,,- Only one per stream pipeline,
,,,"- Examples: collect(), forEach(), reduce(), findFirst()",
,,,,
,,,List<String> result = list.stream() .filter(s -> s.length() > 3) .collect(Collectors.toList()); // terminal,
,,,,
,,,Stream Characteristics:,
,,,- One-time use only,
,,,- Elements processed on-demand,
,,,- Can be parallel or sequential,
9,Exception Handling,Explain the difference between checked and unchecked exceptions. When should you use each?,Checked Exceptions:,"Checked for recoverable conditions, unchecked for programming errors"
,,,- Must be declared in method signature or caught,
,,,- Compile-time enforcement,
,,,- Represent recoverable conditions,
,,,"- Examples: IOException, SQLException",
,,,,
,,,public void readFile() throws IOException { // IOException must be handled or declared },
,,,,
,,,Unchecked Exceptions:,
,,,"- Runtime exceptions, no compile-time checking",
,,,- Usually represent programming errors,
,,,"- Examples: NullPointerException, IllegalArgumentException",
,,,,
,,,"public void divide(int a, int b) { if (b == 0) { throw new IllegalArgumentException(""Division by zero""); } return a / b; }",
,,,,
,,,Best Practices:,
,,,- Use checked exceptions for recoverable conditions,
,,,- Use unchecked exceptions for programming errors,
,,,- Don't catch Exception or Throwable,
,,,- Create custom exceptions when needed,
,,,- Document exceptions in Javadoc,
10,Collections,Explain the internal working of HashMap and how it handles collisions,HashMap Internal Structure:,Tree conversion in Java 8+ improves worst-case performance from O(n) to O(log n)
,,,- Array of buckets (default size 16),
,,,- Each bucket can hold linked list or tree (Java 8+),
,,,- Hash function: key.hashCode() % buckets.length,
,,,,
,,,Collision Handling:,
,,,1. Separate Chaining (pre-Java 8): Linked lists in buckets,
,,,"2. Tree Conversion (Java 8+): When bucket size > 8, convert to Red-Black tree",
,,,,
,,,"// Simplified put operation public V put(K key, V value) { int hash = hash(key); int index = hash & (capacity - 1); Node<K,V> node = table[index]; // Handle collisions and update/insert // Resize if load factor > 0.75 }",
,,,,
,,,Load Factor: 0.75 (resize when 75% full),
,,,Capacity: Always power of 2 for efficient modulo operation,
,,,,
,,,Performance:,
,,,- Average O(1) for get/put,
,,,- Worst case O(log n) with tree (O(n) with only lists),
11,Spring Boot,"What is the difference between @Component, @Service, @Repository, and @Controller?",All are specializations of @Component for dependency injection:,Use specific annotations for better code organization and Spring features
,,,,
,,,@Component: Generic stereotype for any Spring-managed component,
,,,@Component public class UtilityClass { // generic component },
,,,,
,,,"@Service: Business logic layer, contains business rules",
,,,@Service public class UserService { // business operations },
,,,,
,,,"@Repository: Data access layer, provides abstraction over data storage",
,,,@Repository public class UserRepository { // data access operations // Automatic exception translation },
,,,,
,,,"@Controller: Presentation layer, handles HTTP requests",
,,,@Controller public class UserController { // handles web requests },
,,,,
,,,Key Differences:,
,,,- @Repository provides automatic exception translation,
,,,- @Controller is used by Spring MVC for request mapping,
,,,"- @Service is semantic only, same as @Component",
,,,- All create singleton beans by default,
12,Microservices,What are the key considerations when designing microservices in Java?,Service Decomposition:,"Focus on loose coupling, high cohesion, and independent deployability"
,,,- Domain-driven design (DDD),
,,,- Business capability alignment,
,,,- Data ownership per service,
,,,- Avoid distributed monoliths,
,,,,
,,,Communication Patterns:,
,,,"- Synchronous: REST APIs, gRPC",
,,,"- Asynchronous: Message queues (RabbitMQ, Kafka)",
,,,- Event-driven architecture,
,,,,
,,,Data Management:,
,,,- Database per service,
,,,- Eventual consistency,
,,,- Saga pattern for distributed transactions,
,,,- CQRS (Command Query Responsibility Segregation),
,,,,
,,,Cross-cutting Concerns:,
,,,"- Service discovery (Eureka, Consul)",
,,,- Load balancing,
,,,"- Circuit breaker pattern (Hystrix, Resilience4j)",
,,,"- Distributed tracing (Zipkin, Jaeger)",
,,,- Configuration management (Spring Cloud Config),
,,,,
,,,Deployment:,
,,,- Containerization (Docker),
,,,- Orchestration (Kubernetes),
,,,- CI/CD pipelines,
,,,- Independent deployment cycles,
13,Testing,Explain different testing strategies in Java and their use cases,Unit Testing:,"Pyramid approach: Many unit tests, fewer integration tests, minimal E2E tests"
,,,- Test individual components in isolation,
,,,- Use mocking frameworks (Mockito),
,,,"- Fast execution, good coverage",
,,,,
,,,"@Test public void testUserService() { UserRepository mockRepo = mock(UserRepository.class); when(mockRepo.findById(1)).thenReturn(user); UserService service = new UserService(mockRepo); User result = service.getUser(1); assertEquals(""John"", result.getName()); }",
,,,,
,,,Integration Testing:,
,,,- Test component interactions,
,,,- Use @SpringBootTest for Spring applications,
,,,- TestContainers for database testing,
,,,,
,,,@SpringBootTest @TestMethodOrder(OrderAnnotation.class) class UserServiceIntegrationTest { @Autowired UserService userService; @Test void testCompleteUserFlow() { // test full integration } },
,,,,
,,,Contract Testing:,
,,,- API contract verification,
,,,"- Tools: Pact, Spring Cloud Contract",
,,,,
,,,Performance Testing:,
,,,"- JMeter, Gatling",
,,,- Load and stress testing,
14,Security,What are the common security vulnerabilities in Java applications and how to prevent them?,SQL Injection:,"Security should be built into design, not added as an afterthought"
,,,Prevention: Use prepared statements,
,,,"// Vulnerable String query = ""SELECT * FROM users WHERE id = "" + userId; // Secure String query = ""SELECT * FROM users WHERE id = ?""; PreparedStatement stmt = connection.prepareStatement(query); stmt.setInt(1, userId);",
,,,,
,,,Cross-Site Scripting (XSS):,
,,,"Prevention: Input validation, output encoding",
,,,// Use OWASP libraries String safe = Encode.forHtml(userInput);,
,,,,
,,,Authentication & Authorization:,
,,,- Use Spring Security,
,,,- JWT tokens for stateless auth,
,,,- RBAC (Role-Based Access Control),
,,,,
,,,Other Vulnerabilities:,
,,,- Insecure Deserialization: Validate input,
,,,- Path Traversal: Validate file paths,
,,,- CSRF: Use CSRF tokens,
,,,- Information Disclosure: Error handling,
,,,,
,,,Best Practices:,
,,,- Principle of least privilege,
,,,- Input validation and sanitization,
,,,- Regular security audits,
,,,- Keep dependencies updated,
15,JVM Performance,Explain JIT compilation and its impact on Java performance,Just-In-Time (JIT) Compilation:,JIT provides better performance than static compilation through runtime optimization
,,,- Compiles bytecode to native machine code at runtime,
,,,"- Two compilers: C1 (client), C2 (server)",
,,,- Tiered compilation uses both for optimal performance,
,,,,
,,,Compilation Levels:,
,,,0. Interpreter,
,,,1. C1 with simple optimizations,
,,,2. C1 with profiling,
,,,3. C1 with full optimizations,
,,,4. C2 with aggressive optimizations,
,,,,
,,,Optimization Techniques:,
,,,- Method inlining,
,,,- Dead code elimination,
,,,- Loop unrolling,
,,,- Escape analysis,
,,,- Constant folding,
,,,,
,,,Warmup Period:,
,,,- Methods start interpreted,
,,,- Profile data collected during execution,
,,,- Hot methods get compiled,
,,,- Multiple compilation levels,
,,,,
,,,Impact:,
,,,- Initial overhead during warmup,
,,,- Significant performance improvement after compilation,
,,,- Adaptive optimization based on runtime behavior,
16,Functional Programming,How do you implement the Strategy pattern using functional interfaces in Java 8+?,Traditional Strategy Pattern:,Functional interfaces eliminate the need for concrete strategy classes
,,,"interface PaymentStrategy { void pay(double amount); } class CreditCardStrategy implements PaymentStrategy { public void pay(double amount) { System.out.println(""Paid "" + amount + "" using credit card""); } }",
,,,,
,,,Functional Approach:,
,,,"// Using Function interface Function<Double, String> creditCardPayment = amount -> ""Paid "" + amount + "" using credit card""; Function<Double, String> paypalPayment = amount -> ""Paid "" + amount + "" using PayPal""; // Payment processor public class PaymentProcessor { public void processPayment(double amount, Function<Double, String> strategy) { String result = strategy.apply(amount); System.out.println(result); } } // Usage PaymentProcessor processor = new PaymentProcessor(); processor.processPayment(100.0, creditCardPayment); processor.processPayment(50.0, amount -> ""Paid "" + amount + "" using Bitcoin"");",
17,Reflection,What are the use cases and limitations of Java Reflection?,Use Cases:,Powerful but use judiciously due to performance and maintainability costs
,,,"- Frameworks (Spring, Hibernate)",
,,,"- Testing frameworks (JUnit, Mockito)",
,,,"- Serialization libraries (Jackson, Gson)",
,,,- Annotation processing,
,,,- Dynamic proxy creation,
,,,,
,,,"// Basic reflection operations Class<?> clazz = MyClass.class; Constructor<?> constructor = clazz.getConstructor(); Object instance = constructor.newInstance(); Method method = clazz.getMethod(""methodName"", paramTypes); Object result = method.invoke(instance, args); Field field = clazz.getDeclaredField(""fieldName""); field.setAccessible(true); Object value = field.get(instance);",
,,,,
,,,Limitations:,
,,,- Performance overhead (slower than direct access),
,,,- Security restrictions in some environments,
,,,- Loss of compile-time type checking,
,,,- Code complexity and maintainability issues,
,,,- Breaks encapsulation,
,,,,
,,,Best Practices:,
,,,- Cache reflection objects,
,,,- Use sparingly and document well,
,,,"- Consider alternatives (method handles, lambda expressions)",
,,,- Handle security exceptions properly,
18,Generics,Explain type erasure in Java generics and its implications,Type Erasure:,Type erasure enables backward compatibility but limits runtime generic operations
,,,- Generic type information removed at compile time,
,,,- Maintains backward compatibility with pre-generic code,
,,,- Runtime type is the raw type,
,,,,
,,,"List<String> stringList = new ArrayList<>(); List<Integer> intList = new ArrayList<>(); // At runtime, both are just List System.out.println(stringList.getClass() == intList.getClass()); // true",
,,,,
,,,Implications:,
,,,1. Cannot create instances of type parameters:,
,,,// Compilation error T instance = new T();,
,,,,
,,,2. Cannot use instanceof with generic types:,
,,,// Compilation error if (list instanceof List<String>) { } // Correct if (list instanceof List<?>) { },
,,,,
,,,3. Array creation issues:,
,,,// Cannot create generic arrays List<String>[] arrays = new List<String>[10]; // Error,
,,,,
,,,4. Method overloading limitations:,
,,,// Both methods have same signature after erasure void method(List<String> list) { } void method(List<Integer> list) { } // Error,
,,,,
,,,Workarounds:,
,,,- Use Class<T> tokens,
,,,- Type witnesses,
,,,- Wildcard types,
19,Database,"Explain the differences between JPA, Hibernate, and JDBC",JDBC (Java Database Connectivity):,"Choose JDBC for performance-critical apps, JPA/Hibernate for productivity and maintainability"
,,,- Low-level API for database access,
,,,- Direct SQL execution,
,,,- Manual result set mapping,
,,,- Connection management,
,,,,
,,,"String sql = ""SELECT * FROM users WHERE id = ?""; PreparedStatement stmt = connection.prepareStatement(sql); stmt.setInt(1, userId); ResultSet rs = stmt.executeQuery(); while (rs.next()) { String name = rs.getString(""name""); // manual mapping }",
,,,,
,,,JPA (Java Persistence API):,
,,,- Specification for ORM in Java,
,,,- Annotations for mapping,
,,,- JPQL for queries,
,,,- EntityManager for persistence operations,
,,,,
,,,"@Entity public class User { @Id private Long id; @Column private String name; } // Usage EntityManager em = ...; User user = em.find(User.class, 1L);",
,,,,
,,,Hibernate:,
,,,- JPA implementation (most popular),
,,,- Additional features beyond JPA,
,,,- HQL (Hibernate Query Language),
,,,- Caching mechanisms,
,,,- Lazy loading,
,,,,
,,,Relationship:,
,,,JPA (Specification) ← Hibernate (Implementation) ← JDBC (Foundation),
20,Build Tools,Compare Maven and Gradle for Java project management,Maven:,Both are excellent; choice depends on team preferences and project requirements
,,,- XML-based configuration (pom.xml),
,,,- Convention over configuration,
,,,- Declarative approach,
,,,- Extensive plugin ecosystem,
,,,- Mature and stable,
,,,,
,,,<dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-core</artifactId> <version>5.3.21</version> </dependency> </dependencies>,
,,,,
,,,Gradle:,
,,,- Groovy/Kotlin DSL,
,,,- Flexible and programmable,
,,,- Incremental builds,
,,,- Better performance,
,,,- Modern features,
,,,,
,,,dependencies { implementation 'org.springframework:spring-core:5.3.21' testImplementation 'junit:junit:4.13.2' },
,,,,
,,,Key Differences:,
,,,"- Performance: Gradle faster (incremental builds, build cache)",
,,,- Flexibility: Gradle more flexible and programmable,
,,,- Learning curve: Maven simpler for beginners,
,,,- Enterprise adoption: Maven more established,
,,,- Android: Gradle is standard,
,,,,
,,,Choose Maven for:,
,,,- Traditional enterprise projects,
,,,- Teams familiar with XML,
,,,"- Stable, well-defined processes",
,,,,
,,,Choose Gradle for:,
,,,- Modern projects requiring flexibility,
,,,- Performance-critical builds,
,,,- Android development,
21,Collections,Explain ConcurrentHashMap and how it differs from HashMap and Hashtable,ConcurrentHashMap:,ConcurrentHashMap provides thread-safety with better performance than synchronized collections
,,,- Thread-safe without synchronizing entire map,
,,,- Uses segment-based locking (Java 7) or CAS + synchronized (Java 8+),
,,,- Allows concurrent reads and limited concurrent writes,
,,,- No null keys or values allowed,
,,,,
,,,"ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>(); map.put(""key"", 1); map.compute(""key"", (k, v) -> v == null ? 1 : v + 1); // atomic increment map.putIfAbsent(""key2"", 2); // atomic put-if-absent",
,,,,
,,,vs HashMap:,
,,,"- HashMap: Not thread-safe, allows null key/values, better performance for single-threaded",
,,,"- ConcurrentHashMap: Thread-safe, no nulls, slightly slower but safe for concurrent access",
,,,,
,,,vs Hashtable:,
,,,- Hashtable: Synchronized on entire table (poor concurrency),
,,,- ConcurrentHashMap: Fine-grained locking (better concurrency),
,,,,
,,,Java 8+ Improvements:,
,,,- Tree nodes for collision handling,
,,,- CAS operations for better performance,
,,,- Parallel operations support,
,,,- Stream API integration,
22,Concurrency,Explain CompletableFuture and its advantages over traditional Future,Traditional Future Limitations:,CompletableFuture enables reactive programming patterns and better async composition
,,,- Blocking get() method,
,,,- No chaining or composition,
,,,- Limited exception handling,
,,,- Cannot combine multiple futures,
,,,,
,,,CompletableFuture Advantages:,
,,,- Non-blocking with callbacks,
,,,- Fluent API for chaining,
,,,- Composition of multiple async operations,
,,,- Better exception handling,
,,,,
,,,"// Traditional Future Future<String> future = executor.submit(() -> ""Hello""); String result = future.get(); // blocking // CompletableFuture CompletableFuture<String> cf = CompletableFuture .supplyAsync(() -> ""Hello"") .thenApply(s -> s + "" World"") .thenCompose(s -> CompletableFuture.supplyAsync(() -> s + ""!"")) .exceptionally(ex -> ""Error: "" + ex.getMessage()); // Non-blocking callback cf.thenAccept(result -> System.out.println(result)); // Combining multiple futures CompletableFuture<String> combined = CompletableFuture .allOf(future1, future2, future3) .thenApply(v -> future1.join() + future2.join() + future3.join());",
,,,,
,,,Common Patterns:,
,,,- supplyAsync(): For supplier functions,
,,,- thenApply(): Transform result,
,,,- thenCompose(): Chain dependent futures,
,,,- thenCombine(): Combine independent futures,
,,,- exceptionally(): Handle exceptions,
,,,- allOf()/anyOf(): Wait for multiple futures,
23,Design Patterns,Implement the Observer pattern using modern Java features,Traditional Observer Pattern:,Functional interfaces provide cleaner implementation than traditional OOP observer pattern
,,,interface Observer { void update(String message); } class Subject { private List<Observer> observers = new ArrayList<>(); public void addObserver(Observer observer) { observers.add(observer); } public void notifyObservers(String message) { observers.forEach(observer -> observer.update(message)); } },
,,,,
,,,Modern Functional Approach:,
,,,"import java.util.function.Consumer; class EventPublisher { private final List<Consumer<String>> listeners = new ArrayList<>(); public void subscribe(Consumer<String> listener) { listeners.add(listener); } public void unsubscribe(Consumer<String> listener) { listeners.remove(listener); } public void publish(String event) { listeners.forEach(listener -> listener.accept(event)); } } // Usage EventPublisher publisher = new EventPublisher(); publisher.subscribe(event -> System.out.println(""Handler 1: "" + event)); publisher.subscribe(event -> logToFile(event)); publisher.subscribe(event -> sendNotification(event)); publisher.publish(""User logged in"");",
,,,,
,,,Reactive Streams Approach (with Flow API):,
,,,import java.util.concurrent.Flow.*; class EventStream implements Publisher<String> { private final List<Subscriber<? super String>> subscribers = new ArrayList<>(); @Override public void subscribe(Subscriber<? super String> subscriber) { subscribers.add(subscriber); subscriber.onSubscribe(new SimpleSubscription()); } public void publish(String event) { subscribers.forEach(sub -> sub.onNext(event)); } },
24,Java 8+ Features,Explain Optional class and best practices for using it,Purpose of Optional:,Optional eliminates null checks but should be used judiciously for return types only
,,,- Represents optional values instead of null,
,,,- Reduces NullPointerException,
,,,- Makes null-handling explicit,
,,,- Functional programming style,
,,,,
,,,Creating Optional:,
,,,"// Creating Optional instances Optional<String> empty = Optional.empty(); Optional<String> nonNull = Optional.of(""value""); // throws if null Optional<String> nullable = Optional.ofNullable(getValue()); // safe for null",
,,,,
,,,Using Optional:,
,,,"// Check and retrieve if (optional.isPresent()) { String value = optional.get(); // use only after isPresent() } // Functional approach (preferred) optional.ifPresent(value -> System.out.println(value)); // Transformations Optional<String> upperCase = optional.map(String::toUpperCase); Optional<Integer> length = optional.map(String::length); // Chaining String result = optional .filter(s -> s.length() > 5) .map(String::toUpperCase) .orElse(""DEFAULT""); // Fallback values String value1 = optional.orElse(""default""); String value2 = optional.orElseGet(() -> computeDefault()); String value3 = optional.orElseThrow(() -> new IllegalStateException());",
,,,,
,,,Best Practices:,
,,,- Never assign null to Optional,
,,,"- Use Optional for return types, not fields",
,,,- Prefer ifPresent() over isPresent() + get(),
,,,- Use map() and flatMap() for transformations,
,,,- Don't use Optional in collections,
,,,,
,,,Anti-patterns:,
,,,"// DON'T do this Optional<String> opt = Optional.ofNullable(getValue()); if (opt.isPresent()) { return opt.get(); } else { return ""default""; } // DO this instead return Optional.ofNullable(getValue()).orElse(""default"");",
25,Spring AOP,Explain Aspect-Oriented Programming in Spring and its use cases,AOP Concepts:,"AOP separates cross-cutting concerns from business logic for cleaner, more maintainable code"
,,,"- Aspect: Cross-cutting concern (logging, security)",
,,,- Join Point: Execution points (method calls),
,,,- Pointcut: Where to apply advice,
,,,"- Advice: What to do (before, after, around)",
,,,- Weaving: Process of applying aspects,
,,,,
,,,Types of Advice:,
,,,"@Aspect @Component public class LoggingAspect { @Before(""execution(* com.example.service.*.*(..))"") public void beforeMethod(JoinPoint joinPoint) { System.out.println(""Before: "" + joinPoint.getSignature().getName()); } @After(""execution(* com.example.service.*.*(..))"") public void afterMethod(JoinPoint joinPoint) { System.out.println(""After: "" + joinPoint.getSignature().getName()); } @Around(""@annotation(Timed)"") public Object measureExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable { long start = System.currentTimeMillis(); try { return joinPoint.proceed(); } finally { long duration = System.currentTimeMillis() - start; System.out.println(""Execution time: "" + duration + ""ms""); } } @AfterReturning(value = ""execution(* com.example.service.*.*(..))"", returning = ""result"") public void afterReturning(JoinPoint joinPoint, Object result) { System.out.println(""Method returned: "" + result); } @AfterThrowing(value = ""execution(* com.example.service.*.*(..))"", throwing = ""exception"") public void afterThrowing(JoinPoint joinPoint, Exception exception) { System.out.println(""Exception in method: "" + exception.getMessage()); } }",
,,,,
,,,Pointcut Expressions:,
,,,"// Method execution @Pointcut(""execution(* com.example.service.*.*(..))"") // Annotation-based @Pointcut(""@annotation(org.springframework.transaction.annotation.Transactional)"") // Bean-based @Pointcut(""bean(*Service)"") // Parameter-based @Pointcut(""execution(* com.example.service.*.*(String, ..)) && args(name,..)"")",
,,,,
,,,Common Use Cases:,
,,,- Logging and auditing,
,,,- Security and authorization,
,,,- Transaction management,
,,,- Performance monitoring,
,,,- Caching,
,,,- Exception handling,
,,,,
,,,Proxy Mechanisms:,
,,,- JDK Dynamic Proxy: Interface-based,
,,,- CGLIB Proxy: Class-based (default in Spring Boot),
26,Serialization,"Explain Java serialization, its challenges, and modern alternatives",Java Serialization Basics:,Avoid Java serialization due to security and compatibility issues; prefer JSON or binary alternatives
,,,"public class User implements Serializable { private static final long serialVersionUID = 1L; private String name; private int age; private transient String password; // not serialized // writeObject and readObject for custom serialization private void writeObject(ObjectOutputStream oos) throws IOException { oos.defaultWriteObject(); oos.writeObject(encrypt(password)); } private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { ois.defaultReadObject(); password = decrypt((String) ois.readObject()); } }",
,,,,
,,,Serialization Challenges:,
,,,- Security vulnerabilities (deserialization attacks),
,,,- Version compatibility issues,
,,,- Performance overhead,
,,,- Platform dependency,
,,,- Breaks encapsulation,
,,,- Complex inheritance scenarios,
,,,,
,,,Security Issues:,
,,,"// Vulnerable deserialization ObjectInputStream ois = new ObjectInputStream(inputStream); Object obj = ois.readObject(); // Can execute malicious code // Safer approach with filtering (Java 9+) ObjectInputStream ois = new ObjectInputStream(inputStream); ois.setObjectInputFilter(ObjectInputFilter.Config.createFilter( ""com.example.SafeClass;!*"")); // whitelist approach",
,,,,
,,,Modern Alternatives:,
,,,,
,,,JSON (Jackson):,
,,,"@JsonIgnoreProperties(ignoreUnknown = true) public class User { @JsonProperty(""user_name"") private String name; @JsonIgnore private String password; }",
,,,,
,,,Protocol Buffers:,
,,,"// user.proto message User { string name = 1; int32 age = 2; } // Java usage User user = User.newBuilder() .setName(""John"") .setAge(30) .build(); byte[] data = user.toByteArray();",
,,,,
,,,"Avro, MessagePack, Kryo: Other binary serialization formats",
,,,,
,,,Best Practices:,
,,,- Avoid Java serialization for new projects,
,,,- Use JSON for human-readable data,
,,,- Use binary formats for performance,
,,,- Implement proper versioning,
,,,- Validate all external input,
27,JVM Internals,Explain the Java class loading mechanism and custom class loaders,Class Loading Hierarchy:,Understanding class loading is crucial for debugging classpath issues and building modular applications
,,,1. Bootstrap ClassLoader: Loads core Java classes (rt.jar),
,,,2. Extension ClassLoader: Loads extension libraries (ext directory),
,,,3. Application ClassLoader: Loads application classes (classpath),
,,,4. Custom ClassLoaders: User-defined loaders,
,,,,
,,,Class Loading Process:,
,,,1. Loading: Find and load .class file,
,,,"2. Linking: Verification, preparation, resolution",
,,,3. Initialization: Execute static initializers,
,,,,
,,,Parent Delegation Model:,
,,,"// ClassLoader delegation public Class<?> loadClass(String name) throws ClassNotFoundException { // Check if already loaded Class<?> c = findLoadedClass(name); if (c == null) { // Delegate to parent first if (parent != null) { c = parent.loadClass(name); } else { c = findBootstrapClassOrNull(name); } // If parent cannot load, try this loader if (c == null) { c = findClass(name); } } return c; }",
,,,,
,,,Custom ClassLoader Example:,
,,,"public class CustomClassLoader extends ClassLoader { private String classPath; public CustomClassLoader(String classPath) { this.classPath = classPath; } @Override protected Class<?> findClass(String name) throws ClassNotFoundException { try { byte[] classData = loadClassData(name); return defineClass(name, classData, 0, classData.length); } catch (IOException e) { throw new ClassNotFoundException(""Class not found: "" + name, e); } } private byte[] loadClassData(String className) throws IOException { String fileName = classPath + File.separator + className.replace('.', File.separatorChar) + "".class""; return Files.readAllBytes(Paths.get(fileName)); } }",
,,,,
,,,Use Cases for Custom ClassLoaders:,
,,,- Hot deployment in application servers,
,,,- Plugin architectures,
,,,- Loading classes from databases,
,,,- Encrypted class files,
,,,- Isolation between modules,
,,,,
,,,Class Loading Issues:,
,,,- ClassNotFoundException vs NoClassDefFoundError,
,,,- Memory leaks from static references,
,,,- ClassCastException with multiple loaders,
,,,- Thread context class loader problems,
28,REST & Web Services,Design and implement a RESTful API with proper HTTP status codes and error handling,REST Principles:,RESTful design with proper status codes and error handling improves API usability and debugging
,,,- Stateless communication,
,,,- Resource-based URLs,
,,,- HTTP methods for operations,
,,,- HATEOAS (Hypermedia as the Engine of Application State),
,,,- Uniform interface,
,,,,
,,,Resource Design:,
,,,"@RestController @RequestMapping(""/api/v1/users"") @Validated public class UserController { @GetMapping public ResponseEntity<PagedResponse<UserDTO>> getUsers( @RequestParam(defaultValue = ""0"") int page, @RequestParam(defaultValue = ""10"") int size) { Page<User> users = userService.findAll(PageRequest.of(page, size)); return ResponseEntity.ok(new PagedResponse<>(users)); } @GetMapping(""/{id}"") public ResponseEntity<UserDTO> getUser(@PathVariable Long id) { return userService.findById(id) .map(user -> ResponseEntity.ok(userMapper.toDTO(user))) .orElse(ResponseEntity.notFound().build()); } @PostMapping public ResponseEntity<UserDTO> createUser(@Valid @RequestBody CreateUserRequest request) { User user = userService.create(request); URI location = ServletUriComponentsBuilder .fromCurrentRequest() .path(""/{id}"") .buildAndExpand(user.getId()) .toUri(); return ResponseEntity.created(location).body(userMapper.toDTO(user)); } @PutMapping(""/{id}"") public ResponseEntity<UserDTO> updateUser(@PathVariable Long id, @Valid @RequestBody UpdateUserRequest request) { return userService.update(id, request) .map(user -> ResponseEntity.ok(userMapper.toDTO(user))) .orElse(ResponseEntity.notFound().build()); } @DeleteMapping(""/{id}"") public ResponseEntity<Void> deleteUser(@PathVariable Long id) { if (userService.delete(id)) { return ResponseEntity.noContent().build(); } return ResponseEntity.notFound().build(); } }",
,,,,
,,,HTTP Status Codes:,
,,,"- 200 OK: Successful GET, PUT",
,,,- 201 Created: Successful POST,
,,,- 204 No Content: Successful DELETE,
,,,- 400 Bad Request: Invalid input,
,,,- 401 Unauthorized: Authentication required,
,,,- 403 Forbidden: Access denied,
,,,- 404 Not Found: Resource not found,
,,,- 409 Conflict: Resource conflict,
,,,- 422 Unprocessable Entity: Validation error,
,,,- 500 Internal Server Error: Server error,
,,,,
,,,Error Handling:,
,,,"@ControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(ResourceNotFoundException.class) public ResponseEntity<ErrorResponse> handleNotFound(ResourceNotFoundException ex) { ErrorResponse error = ErrorResponse.builder() .timestamp(Instant.now()) .status(404) .error(""Not Found"") .message(ex.getMessage()) .path(getCurrentPath()) .build(); return ResponseEntity.status(404).body(error); } @ExceptionHandler(MethodArgumentNotValidException.class) public ResponseEntity<ErrorResponse> handleValidation(MethodArgumentNotValidException ex) { Map<String, String> fieldErrors = ex.getBindingResult() .getFieldErrors() .stream() .collect(Collectors.toMap( FieldError::getField, FieldError::getDefaultMessage )); ErrorResponse error = ErrorResponse.builder() .timestamp(Instant.now()) .status(422) .error(""Validation Failed"") .message(""Invalid input parameters"") .fieldErrors(fieldErrors) .path(getCurrentPath()) .build(); return ResponseEntity.status(422).body(error); } }",
29,Caching,Explain different caching strategies in Java applications and their trade-offs,Caching Levels:,"Choose caching strategy based on read/write patterns, consistency requirements, and performance goals"
,,,1. Browser/Client Cache,
,,,2. CDN/Reverse Proxy Cache,
,,,3. Application Cache,
,,,4. Database Cache,
,,,,
,,,Application-Level Caching:,
,,,,
,,,Spring Cache Abstraction:,
,,,"@Service public class UserService { @Cacheable(value = ""users"", key = ""#id"") public User findById(Long id) { // Expensive database operation return userRepository.findById(id); } @CachePut(value = ""users"", key = ""#user.id"") public User update(User user) { return userRepository.save(user); } @CacheEvict(value = ""users"", key = ""#id"") public void delete(Long id) { userRepository.deleteById(id); } @CacheEvict(value = ""users"", allEntries = true) public void clearAllUsers() { // Clears entire cache } @Caching(evict = { @CacheEvict(value = ""users"", key = ""#user.id""), @CacheEvict(value = ""userStats"", allEntries = true) }) public User updateUserWithStats(User user) { return userRepository.save(user); } }",
,,,,
,,,Cache Providers:,
,,,,
,,,Redis Configuration:,
,,,@Configuration @EnableCaching public class CacheConfig { @Bean public CacheManager cacheManager(RedisConnectionFactory connectionFactory) { RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofMinutes(10)) .serializeKeysWith(RedisSerializationContext.SerializationPair .fromSerializer(new StringRedisSerializer())) .serializeValuesWith(RedisSerializationContext.SerializationPair .fromSerializer(new GenericJackson2JsonRedisSerializer())); return RedisCacheManager.builder(connectionFactory) .cacheDefaults(config) .build(); } },
,,,,
,,,Caffeine (In-Memory) Configuration:,
,,,"@Bean public CacheManager caffeineCacheManager() { CaffeineCacheManager cacheManager = new CaffeineCacheManager(); cacheManager.setCaffeine(Caffeine.newBuilder() .maximumSize(1000) .expireAfterWrite(10, TimeUnit.MINUTES) .recordStats()); return cacheManager; }",
,,,,
,,,Cache Strategies:,
,,,,
,,,1. Cache-Aside (Lazy Loading):,
,,,- Application manages cache,
,,,- Read: Check cache → DB if miss → Update cache,
,,,- Write: Update DB → Invalidate cache,
,,,,
,,,2. Write-Through:,
,,,- Write to cache and DB simultaneously,
,,,- Ensures consistency but slower writes,
,,,,
,,,3. Write-Behind (Write-Back):,
,,,"- Write to cache immediately, DB asynchronously",
,,,- Faster writes but risk of data loss,
,,,,
,,,Cache Patterns:,
,,,- TTL (Time To Live): Automatic expiration,
,,,- LRU (Least Recently Used): Eviction strategy,
,,,- Circuit Breaker: Fallback when cache fails,
,,,- Cache Warming: Pre-populate cache,
,,,,
,,,Trade-offs:,
,,,- Memory vs Speed,
,,,- Consistency vs Performance,
,,,- Complexity vs Simplicity,
,,,- Cache invalidation challenges,
30,Reactive Programming,Explain reactive programming with Spring WebFlux and when to use it,Reactive Programming Principles:,WebFlux excels in I/O-intensive applications but adds complexity; use for high-concurrency scenarios
,,,- Asynchronous and non-blocking,
,,,- Event-driven and message-driven,
,,,- Elastic and resilient,
,,,- Responsive under load,
,,,,
,,,Reactive Streams API:,
,,,- Publisher: Emits data,
,,,- Subscriber: Consumes data,
,,,- Subscription: Controls flow,
,,,- Processor: Both publisher and subscriber,
,,,,
,,,Spring WebFlux Example:,
,,,"@RestController public class ReactiveUserController { @Autowired private ReactiveUserService userService; @GetMapping(""/users"") public Flux<User> getAllUsers() { return userService.findAll() .delayElements(Duration.ofMillis(100)) // Simulate delay .map(this::enrichUser); } @GetMapping(""/users/{id}"") public Mono<ResponseEntity<User>> getUser(@PathVariable String id) { return userService.findById(id) .map(user -> ResponseEntity.ok(user)) .defaultIfEmpty(ResponseEntity.notFound().build()); } @PostMapping(""/users"") public Mono<User> createUser(@RequestBody Mono<User> userMono) { return userMono .flatMap(this::validateUser) .flatMap(userService::save) .doOnSuccess(user -> publishUserCreatedEvent(user)) .doOnError(error -> log.error(""Failed to create user"", error)); } @GetMapping(value = ""/users/stream"", produces = MediaType.TEXT_EVENT_STREAM_VALUE) public Flux<User> streamUsers() { return userService.findAll() .delayElements(Duration.ofSeconds(1)) .repeat(); } }",
,,,,
,,,Reactive Service Layer:,
,,,"@Service public class ReactiveUserService { @Autowired private ReactiveMongoTemplate mongoTemplate; @Autowired private WebClient webClient; public Flux<User> findAll() { return mongoTemplate.findAll(User.class); } public Mono<User> findById(String id) { return mongoTemplate.findById(id, User.class); } public Mono<User> save(User user) { return mongoTemplate.save(user); } // Reactive composition public Mono<UserProfile> getUserProfile(String userId) { Mono<User> userMono = findById(userId); Mono<List<Order>> ordersMono = getOrdersForUser(userId); Mono<Preferences> prefsMono = getPreferencesForUser(userId); return Mono.zip(userMono, ordersMono, prefsMono) .map(tuple -> new UserProfile(tuple.getT1(), tuple.getT2(), tuple.getT3())); } // Non-blocking HTTP calls private Mono<List<Order>> getOrdersForUser(String userId) { return webClient.get() .uri(""/orders/user/{userId}"", userId) .retrieve() .bodyToFlux(Order.class) .collectList() .timeout(Duration.ofSeconds(5)) .onErrorReturn(Collections.emptyList()); } }",
,,,,
,,,Error Handling:,
,,,"public Mono<User> processUser(String id) { return findById(id) .switchIfEmpty(Mono.error(new UserNotFoundException(id))) .flatMap(this::validateUser) .onErrorMap(ValidationException.class, ex -> new BadRequestException(""Invalid user data"")) .retry(3) .timeout(Duration.ofSeconds(10)) .doOnError(ex -> log.error(""Error processing user: "" + id, ex)); }",
,,,,
,,,When to Use WebFlux:,
,,,✅ Good for:,
,,,- High concurrency with I/O operations,
,,,- Streaming data,
,,,- Microservices with many external calls,
,,,- Real-time applications,
,,,,
,,,❌ Avoid for:,
,,,- CPU-intensive operations,
,,,- Blocking database drivers,
,,,- Simple CRUD applications,
,,,- Teams new to reactive programming,
,,,,
,,,Performance Benefits:,
,,,- Better resource utilization,
,,,- Higher throughput under load,
,,,- Lower memory footprint,
,,,- Backpressure handling,
