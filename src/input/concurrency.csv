gfQX1F7RffZ2U3Nd5aCN,1,Concurrency,Explain the Java Memory Model (JMM) and its importance.,"The Java Memory Model (JMM) defines how threads interact with memory and ensures consistent behavior across different platforms. It establishes rules for visibility, ordering, and atomicity of shared variables. Key concepts: 1) Each thread has its own working memory (cache), 2) Changes to shared variables must be synchronized to be visible to other threads, 3) Happens-before relationships determine memory visibility guarantees.","JMM prevents issues like stale reads, lost updates, and inconsistent state. Understanding JMM is crucial for writing correct concurrent code."
sTSvXYv1ulVbEpZgcia0,2,Concurrency,Explain the Java Memory Model (JMM) and its importance.,The Java Memory Model (JMM) defines how threads interact with memory.,
p8XGpHKGTSEaXAAXT1lb,3,Concurrency,Explain the Java Memory Model (JMM) and its importance.,"The Java Memory Model (JMM) defines how threads interact with memory and ensures consistent behavior across different platforms. It establishes rules for visibility, ordering, and atomicity of shared variables. Key concepts: 1) Each thread has its own working memory (cache), 2) Changes to shared variables must be synchronized to be visible to other threads, 3) Happens-before relationships determine memory visibility guarantees.","JMM prevents issues like stale reads, lost updates, and inconsistent state. Understanding JMM is crucial for writing correct concurrent code."
lsxANpaQgKWYpYduSbWI,4,Concurrency,"What is the difference between synchronized, volatile, and atomic variables?","synchronized: Provides mutual exclusion and memory visibility. Blocks other threads from accessing the synchronized block/method. volatile: Ensures memory visibility across threads but doesn't provide atomicity for compound operations. Prevents instruction reordering. Atomic variables: Thread-safe operations without locking using compare-and-swap (CAS). Examples: AtomicInteger, AtomicReference.",Key differences: synchronized is heavyweight but provides both atomicity and visibility; volatile is lightweight but provides only visibility; atomic variables are lock-free and provide both atomicity and visibility for specific operations.
y008FcozDa21LuceSpgP,5,Concurrency,What are the different ways to create threads in Java?,1) Extend Thread class: class MyThread extends Thread { public void run() {...} } 2) Implement Runnable interface: class MyTask implements Runnable { public void run() {...} } 3) Implement Callable interface (returns value): class MyCallable implements Callable<String> { public String call() {...} } 4) Using lambda expressions: Thread t = new Thread(() -> { /* code */ }); 5) Using ExecutorService with thread pools,Implementing Runnable is preferred over extending Thread because Java supports single inheritance. Callable is useful when you need return values from threads.
4dqWcwyGKfSjX7ew7x8I,6,Concurrency,What are `CountDownLatch`,`CyclicBarrier`,and `Phaser`? When would you use each?
Js4YeN0IOfI9SVpMI8FU,7,Concurrency,What are the different ways to create threads in Java?,1) Extend Thread class: class MyThread extends Thread { public void run() {...} } 2) Implement Runnable interface: class MyTask implements Runnable { public void run() {...} } 3) Implement Callable interface (returns value): class MyCallable implements Callable<String> { public String call() {...} } 4) Using lambda expressions: Thread t = new Thread(() -> { /* code */ }); 5) Using ExecutorService with thread pools,Implementing Runnable is preferred over extending Thread because Java supports single inheritance. Callable is useful when you need return values from threads.
T0PCte5wvBL0nOaUvO4y,8,Concurrency,"Explain CountDownLatch, CyclicBarrier, and Semaphore. When would you use each?",CountDownLatch: One-time synchronization primitive. Threads wait until a count reaches zero. Use case: Wait for multiple tasks to complete. CyclicBarrier: Reusable synchronization point where threads wait for each other. Use case: Parallel algorithms with phases. Semaphore: Controls access to a resource pool with permits. Use case: Limiting concurrent access to resources.,"CountDownLatch is one-time use, CyclicBarrier is reusable. Semaphore manages resource access with acquire()/release() methods."
na9sgofagos4Y4I1nYY8,9,Concurrency,"Explain CountDownLatch, CyclicBarrier, and Semaphore. When would you use each?",CountDownLatch: One-time synchronization primitive. Threads wait until a count reaches zero.,
M2HHedYppDD0WlIP9SeA,10,Concurrency,"Explain CountDownLatch, CyclicBarrier, and Semaphore. When would you use each?",CountDownLatch: One-time synchronization primitive. Threads wait until a count reaches zero. Use case: Wait for multiple tasks to complete. CyclicBarrier: Reusable synchronization point where threads wait for each other. Use case: Parallel algorithms with phases. Semaphore: Controls access to a resource pool with permits. Use case: Limiting concurrent access to resources.,"CountDownLatch is one-time use, CyclicBarrier is reusable. Semaphore manages resource access with acquire()/release() methods."
OeJWYOMa6uoqbtsd38Rz,11,Concurrency,Differentiate between synchronized keyword and ReentrantLock.,"synchronized: Built-in keyword, automatically releases lock, simpler syntax, non-interruptible. ReentrantLock: More flexible, supports tryLock(), lockInterruptibly(), condition variables, fair/unfair locking, must manually unlock in finally block.","ReentrantLock provides more control but requires careful management. Use synchronized for simple cases, ReentrantLock for advanced scenarios like timeouts or fair locking."
CURy2pL8Cwa6ZUTnrkKW,12,Concurrency,"Explain the CountDownLatch, CyclicBarrier, and Semaphore. When would you use each?","CountDownLatch: One-time synchronization primitive. Threads wait until a count reaches zero.CountDownLatch latch = new CountDownLatch(3); // Workers count down, main thread waits latch.await(); // blocks until count = 0 latch.countDown(); // decrements count",
bob8YUAMxrxsQBHnbrBt,13,Concurrency,Differentiate between synchronized keyword and ReentrantLock.,"synchronized: Built-in keyword, automatically releases lock, simpler syntax, non-interruptible. ReentrantLock: More flexible, supports tryLock(), lockInterruptibly(), condition variables, fair/unfair locking, must manually unlock in finally block.","ReentrantLock provides more control but requires careful management. Use synchronized for simple cases, ReentrantLock for advanced scenarios like timeouts or fair locking."
VC5srKVqZhfpwYMemDJ3,14,Concurrency,What is a deadlock and how can you prevent it?,"Deadlock occurs when two or more threads are blocked forever, each waiting for the other to release a resource. Example: Thread A holds Lock1 and waits for Lock2, while Thread B holds Lock2 and waits for Lock1.","Prevention strategies: 1) Lock ordering (always acquire locks in same order), 2) Lock timeout (use tryLock with timeout), 3) Avoid nested locks, 4) Use higher-level concurrency utilities."
6d3WkTdqvJAIffTo5MHi,15,Concurrency,Differentiate between `synchronized` keyword and `ReentrantLock`.,Both provide mutual exclusion,but `ReentrantLock` offers more flexibility:
7PkZl6gDfPSJ8UypoJNu,16,Concurrency,What is a deadlock and how can you prevent it?,"Deadlock occurs when two or more threads are blocked forever, each waiting for the other to release a resource. Example: Thread A holds Lock1 and waits for Lock2, while Thread B holds Lock2 and waits for Lock1.","Prevention strategies: 1) Lock ordering (always acquire locks in same order), 2) Lock timeout (use tryLock with timeout), 3) Avoid nested locks, 4) Use higher-level concurrency utilities."
lXvshBatwQuDFGy4ryAO,17,Concurrency,Describe the purpose of ThreadLocal in Java.,"ThreadLocal provides thread-local variables. Each thread accessing a ThreadLocal instance gets its own independently initialized copy of the variable. Useful for storing per-thread context like user sessions, database connections, or transaction information.",Common pattern: private static final ThreadLocal<SimpleDateFormat> formatter = ThreadLocal.withInitial(() -> new SimpleDateFormat(yyyy-MM-dd)); Helps avoid synchronization overhead and thread safety issues.
fiHZjyQHrn5xSL6We2oM,18,Concurrency,Explain the Producer-Consumer pattern and how to implement it in Java.,"Producer-Consumer pattern involves producer threads generating data and consumer threads processing it, typically using a shared buffer. Implementation approaches: 1) Using BlockingQueue (recommended), 2) Using wait()/notify() with synchronized blocks, 3) Using concurrent collections like ArrayBlockingQueue, LinkedBlockingQueue.","BlockingQueue automatically handles blocking when queue is full (producer) or empty (consumer), making implementation much simpler and less error-prone than manual wait/notify."
dUbL5RXHzB66F3ExJlAj,19,Concurrency,What is CompletableFuture and how is it used for asynchronous programming?,"CompletableFuture (Java 8+) provides a way to write asynchronous, non-blocking code. It represents a future result of an asynchronous computation. Key methods: supplyAsync(), thenApply(), thenCompose(), thenCombine(), exceptionally(), allOf(), anyOf().",Supports method chaining for complex async workflows. Example: CompletableFuture.supplyAsync(() -> fetchData()).thenApply(data -> processData(data)).thenAccept(result -> saveResult(result));
Vv3QwpOkWUvbjjxnL4eS,20,Concurrency,Explain ExecutorService and thread pools. What are the different types available?,"ExecutorService manages a pool of threads for executing tasks. Types: 1) newFixedThreadPool(n) - fixed number of threads, 2) newCachedThreadPool() - creates threads as needed, 3) newSingleThreadExecutor() - single worker thread, 4) newScheduledThreadPool(n) - supports delayed/periodic execution. Always shutdown executors to prevent resource leaks.","Thread pools avoid overhead of creating/destroying threads. Choose type based on workload: fixed for stable load, cached for variable load, single for sequential processing, scheduled for timed tasks."
HOdGWNk3VFli7HrNhoTt,21,Concurrency,What is a `CompletableFuture` in Java? How is it used for asynchronous programming?,`CompletableFuture` (since Java 8) provides a way to write asynchronous,non-blocking code. It represents a future result of an asynchronous computation. It supports chaining multiple asynchronous operations and combining their results.
VyuKVPBOJsGCKlReBV9D,22,Concurrency,Explain ExecutorService and thread pools. What are the different types available?,ExecutorService manages a pool of threads for executing tasks. Types:,
ssgj2lp93wQFj7Z1avLT,23,Concurrency,Explain ExecutorService and thread pools. What are the different types available?,"ExecutorService manages a pool of threads for executing tasks. Types: 1) newFixedThreadPool(n) - fixed number of threads, 2) newCachedThreadPool() - creates threads as needed, 3) newSingleThreadExecutor() - single worker thread, 4) newScheduledThreadPool(n) - supports delayed/periodic execution. Always shutdown executors to prevent resource leaks.","Thread pools avoid overhead of creating/destroying threads. Choose type based on workload: fixed for stable load, cached for variable load, single for sequential processing, scheduled for timed tasks."
MhiInKqwGP21xrPyRZyJ,24,Concurrency,Describe the purpose of `ThreadLocal` in Java.,`ThreadLocal` provides thread-local variables. Each thread that accesses a `ThreadLocal` instance gets its own independently initialized copy of the variable.,
